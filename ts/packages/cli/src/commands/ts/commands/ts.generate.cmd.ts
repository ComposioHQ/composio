/**
 * The `composio ts generate` command can be configured as follows:
 * - `--compact`: Emit a single module file
 * - `--transpiled`: Emit not just the TypeScript files, but also the transpiled JavaScript files
 * - `--output-dir`: Output directory for the generated TypeScript type stubs.
 * - `--toolkits`: Filter output to only include the specified toolkits. Can be specified multiple times (e.g., --toolkits gmail --toolkits slack)
 *
 * Invariants:
 * - The `--output-dir` cannot refer to a path inside `node_modules`
 * - If `--output-dir` is not specified, the command will use `findComposioCoreGeneratedPath` to locate the `@composio/core` package
 *   and write to it inside `node_modules`
 * - The absence of `--output-dir` implies that, by default, `--transpiled` is set to true
 * - If `--output-dir` is specified, `--transpiled` is, by default, set to false
 * - If `--transpiled` evaluates to true, the sources generated by `generateTypeScriptSources` need to be transpiled to ESM JavaScript too,
 *   and stored along with the generated TypeScript files. CJS is not supported.
 */

import path from 'node:path';
import { Command, Options } from '@effect/cli';
import { Console, Effect, Option, pipe, Array } from 'effect';
import { Match } from 'effect';
import { FileSystem } from '@effect/platform';
import { ComposioToolkitsRepository } from 'src/services/composio-clients';
import { logMetrics } from 'src/effects/log-metrics';
import { NodeProcess } from 'src/services/node-process';
import { createToolkitIndex } from 'src/generation/create-toolkit-index';
import type { GetCmdParams } from 'src/type-utils';
import { generateTypeScriptSources } from 'src/generation/typescript/generate';
import { jsFindComposioCoreGenerated } from 'src/effects/find-composio-core-generated';
import { transpileTypeScriptSources } from 'src/generation/typescript/transpile';
import { BANNER } from 'src/generation/constants';
import type { Toolkit } from 'src/models/toolkits';
import type { TriggerType } from 'src/models/trigger-types';
import type { Tool, ToolsAsEnums } from 'src/models/tools';

export const outputOpt = Options.optional(
  Options.directory('output-dir', {
    exists: 'either',
  })
).pipe(
  Options.withAlias('o'),
  Options.withDescription('Output directory for the generated TypeScript type stubs.')
);

export const compact = Options.boolean('compact').pipe(
  Options.withDefault(false),
  Options.withDescription('Emit a single TypeScript file')
);

export const transpiled = Options.boolean('transpiled').pipe(
  Options.withDefault(false),
  Options.withDescription('Whether to emit transpiled JavaScript alongside TypeScript files')
);

export const typeTools = Options.boolean('type-tools').pipe(
  Options.withDefault(false),
  Options.withDescription(
    'Generate typed input/output schemas for each tool (slower, fetches full tool definitions)'
  )
);

export const toolkitsOpt = Options.text('toolkits').pipe(
  Options.repeated,
  Options.withDescription(
    'Only generate types for specific toolkits (e.g., --toolkits gmail --toolkits slack)'
  )
);

const _tsCmd$Generate = Command.make('generate', {
  outputOpt,
  compact,
  transpiled: transpiled,
  typeTools,
  toolkitsOpt,
}).pipe(
  Command.withDescription(
    'Generate TypeScript types for toolkits, tools, and triggers from the Composio API'
  )
);

/**
 * Result type for fetching toolkit data
 */
type FetchResult = {
  toolkits: ReadonlyArray<Toolkit>;
  triggerTypes: ReadonlyArray<TriggerType>;
  typeableTools:
    | { withTypes: true; tools: ReadonlyArray<Tool> }
    | { withTypes: false; tools: ToolsAsEnums };
};

/**
 * Fetches data for specific toolkits when --toolkits filter is provided.
 * Makes targeted API calls for only the requested toolkits.
 */
function fetchFilteredData(
  client: ComposioToolkitsRepository,
  slugs: ReadonlyArray<string>,
  typeTools: boolean
): Effect.Effect<FetchResult, Error, never> {
  return Effect.gen(function* () {
    yield* Console.log(`Fetching data for ${slugs.length} toolkit(s): ${slugs.join(', ')}...`);

    const [filteredToolkits, filteredTriggerTypes, filteredTypeableTools] = yield* Effect.all(
      [
        // Fetch only the specified toolkits by slug
        Effect.logDebug(`Fetching ${slugs.length} toolkit(s) by slug...`).pipe(
          Effect.flatMap(() =>
            client
              .getToolkitsBySlugs(slugs)
              .pipe(
                Effect.catchTag('services/InvalidToolkitsError', error =>
                  Effect.fail(
                    new Error(
                      `Invalid toolkit(s): ${error.invalidToolkits.join(', ')}. Toolkit not found.`
                    )
                  )
                )
              )
          )
        ),
        // Fetch only trigger types for the specified toolkits
        Effect.logDebug(`Fetching trigger types for ${slugs.length} toolkit(s)...`).pipe(
          Effect.flatMap(() => client.getTriggerTypes(slugs))
        ),
        // Fetch tools for the specified toolkits
        Match.value(typeTools).pipe(
          Match.when(true, withTypes =>
            Effect.logDebug(`Fetching tools with schemas for ${slugs.length} toolkit(s)...`).pipe(
              Effect.flatMap(() => client.getTools(slugs)),
              Effect.map(tools => ({ withTypes, tools }))
            )
          ),
          Match.when(false, withTypes =>
            Effect.logDebug(`Fetching tool names for ${slugs.length} toolkit(s)...`).pipe(
              Effect.flatMap(() => client.getToolsAsEnums()),
              Effect.map(allTools => ({
                withTypes,
                // Filter tool enums by toolkit prefix
                tools: allTools.filter(tool => {
                  const prefix = tool.split('_')[0]?.toLowerCase();
                  return slugs.some(s => s.toLowerCase() === prefix);
                }),
              }))
            )
          ),
          Match.exhaustive
        ),
      ],
      { concurrency: 'unbounded' }
    );

    yield* Console.log(
      `Filtering to ${filteredToolkits.length} toolkit(s): ${filteredToolkits.map(t => t.slug).join(', ')}`
    );

    return {
      toolkits: filteredToolkits,
      triggerTypes: filteredTriggerTypes,
      typeableTools: filteredTypeableTools,
    };
  });
}

/**
 * Fetches all toolkit data when no --toolkits filter is provided.
 * Fetches everything from the API.
 */
function fetchAllData(
  client: ComposioToolkitsRepository,
  typeTools: boolean
): Effect.Effect<FetchResult, Error, never> {
  return Effect.gen(function* () {
    yield* Console.log('Fetching all toolkits, tools, and triggers from Composio API...');

    // Fetch all data in parallel
    // Note: getToolsAsEnums is only called when typeTools === false
    const [allToolkits, allTriggerTypes, allTypeableTools] = yield* Effect.all(
      [
        Effect.logDebug('Fetching all toolkits...').pipe(
          Effect.flatMap(() => client.getToolkits())
        ),
        Effect.logDebug('Fetching all trigger types...').pipe(
          Effect.flatMap(() => client.getTriggerTypes())
        ),
        Match.value(typeTools).pipe(
          Match.when(true, withTypes =>
            Effect.logDebug('Fetching all tools with schemas...').pipe(
              Effect.flatMap(() => client.getTools()),
              Effect.map(tools => ({ withTypes, tools }))
            )
          ),
          Match.when(false, withTypes =>
            Effect.logDebug('Fetching all tool names...').pipe(
              Effect.flatMap(() => client.getToolsAsEnums()),
              Effect.map(tools => ({ withTypes, tools }))
            )
          ),
          Match.exhaustive
        ),
      ],
      { concurrency: 'unbounded' }
    );

    yield* Console.log(`Found ${allToolkits.length} toolkit(s)`);

    return {
      toolkits: allToolkits,
      triggerTypes: allTriggerTypes,
      typeableTools: allTypeableTools,
    };
  });
}

/**
 * Validates that the output directory is not inside node_modules
 */
function validateOutputDir(outputDir: string): Effect.Effect<string, Error, FileSystem.FileSystem> {
  return Effect.gen(function* () {
    const normalizedPath = path.normalize(outputDir);

    if (normalizedPath.includes('node_modules')) {
      return yield* Effect.fail(
        new Error(
          'Output directory cannot be inside node_modules. Please specify a different directory.'
        )
      );
    }

    return outputDir;
  });
}

export const tsCmd$Generate = _tsCmd$Generate.pipe(
  Command.withHandler(params => {
    // Determine if we should compile based on the rules:
    // - If --output-dir is specified, default transpiled to false unless overridden
    // - If no --output-dir, default transpiled to true unless overridden
    const shouldCompile = params.transpiled || !Option.isSome(params.outputOpt);

    return generateTypescriptTypeStubs({
      ...params,
      compact: params.compact,
      transpiled: shouldCompile,
    });
  })
);

export function generateTypescriptTypeStubs({
  outputOpt,
  compact,
  typeTools,
  transpiled = false,
  toolkitsOpt,
}: GetCmdParams<typeof _tsCmd$Generate> & { transpiled?: boolean }) {
  return Effect.gen(function* () {
    const fs = yield* FileSystem.FileSystem;
    const process = yield* NodeProcess;
    const cwd = process.cwd;
    const client = yield* ComposioToolkitsRepository;

    // Determine the actual output directory
    const outputDir = yield* outputOpt.pipe(
      Option.match({
        // If no output directory is specified, use the default, and make sure it exists
        onNone: () => jsFindComposioCoreGenerated(cwd),

        // If an output directory is specified, validate and create it
        onSome: outputDir => validateOutputDir(outputDir),
      })
    );

    yield* Effect.log(`Writing type stubs to ${outputDir}...`);
    yield* fs.makeDirectory(outputDir, { recursive: true });

    // Normalize toolkit slugs if specified (lowercase for API filtering)
    const toolkitSlugsFilter = Array.isNonEmptyArray(toolkitsOpt)
      ? toolkitsOpt.map(s => s.toLowerCase())
      : null;

    // Fetch data using two distinct strategies based on whether --toolkits filter is provided
    const { toolkits, triggerTypes, typeableTools } = yield* toolkitSlugsFilter !== null
      ? fetchFilteredData(client, toolkitSlugsFilter, typeTools)
      : fetchAllData(client, typeTools);

    yield* Console.log('Writing TypeScript type stubs to disk...');
    const index = createToolkitIndex({ toolkits, typeableTools, triggerTypes });

    // Generate TypeScript sources
    const sources = yield* generateTypeScriptSources({
      outputDir,
      emitSingleFile: Boolean(compact), // Ensure boolean type
      banner: BANNER,
      importExtension: 'js',
    })(index);

    // Write all generated files
    yield* pipe(
      Effect.all(
        sources.map(([filePath, content]) =>
          fs
            .writeFileString(filePath, content)
            .pipe(Effect.mapError(error => new Error(`Failed to write file ${filePath}: ${error}`)))
        ),
        { concurrency: 'unbounded' }
      ),
      Effect.mapError(error => new Error(`Failed to write generated files: ${error}`))
    );

    // Compile TypeScript to JavaScript if needed
    if (transpiled) {
      yield* pipe(
        transpileTypeScriptSources({ sources, outputDir }),
        Effect.catchAll(error =>
          Effect.logWarning(`Failed to compile TypeScript files: ${error.message}`)
        )
      );
    }

    yield* Option.isNone(outputOpt)
      ? Console.log(
          '✅ Type stubs generated successfully.\n' +
            'You can now import generated types via `import { Toolkits } from "@composio/core/generated"`'
        )
      : Console.log(
          `✅ Type stubs generated successfully.\n` +
            `Generated files are available at: ${outputDir}`
        );

    // Log API metrics
    const metrics = yield* client.getMetrics();
    yield* logMetrics(metrics);

    return outputDir;
  });
}
