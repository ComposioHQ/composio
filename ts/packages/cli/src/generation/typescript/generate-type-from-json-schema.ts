import ts from 'typescript';
import openapiTS, { type OpenAPI3, astToString } from 'openapi-typescript';
import { Effect } from 'effect';
import { TaggedError } from 'effect/Data';

export class GenerateTypeFromJsonSchemaError extends TaggedError('json-parsing-error')<{
  cause?: unknown;
  message?: string;
}> {}

export function generateTypeFromJsonSchema(
  name: string,
  schema: { readonly [x: string]: unknown }
) {
  const openApi3Definition = {
    openapi: '3.1.0',
    components: {
      schemas: {
        [name]: {
          type: 'object',
          properties: schema['properties'],
        },
      },
    },
  } as unknown as OpenAPI3;

  return Effect.gen(function* () {
    const astNodes = yield* Effect.tryPromise({
      try: () => openapiTS(openApi3Definition),
      catch: e =>
        new GenerateTypeFromJsonSchemaError({
          cause: e,
          message: 'Failed to generate type from JSON schema',
        }),
    });

    const components = astNodes.find(isInterfaceComponents);

    if (components === undefined) {
      return yield* Effect.fail(
        new GenerateTypeFromJsonSchemaError({
          message:
            'Failed to find `components` interface in types generated by `openapi-typescript`',
        })
      );
    }

    // This is the TypeScript definition obtained via `openapi-typescript`, which contains the types we want + some garbage we don't need.
    // We thus have to extract the type we want using the TypeScript API.
    const sourceCode = astToString(components);

    const sourceFile = ts.createSourceFile('virtual.ts', sourceCode, ts.ScriptTarget.Latest, true);

    // Navigate to components.schemas[name]
    const schemasProp = components.members.find(
      m => ts.isPropertySignature(m) && (m.name as ts.Identifier).text === 'schemas'
    ) as ts.PropertySignature | undefined;

    if (!schemasProp || !schemasProp.type || !ts.isTypeLiteralNode(schemasProp.type)) {
      return yield* Effect.fail(
        new GenerateTypeFromJsonSchemaError({
          message: '`schemas` is not a type literal',
        })
      );
    }

    const schemasTypeLiteral = schemasProp.type;
    const payloadProp = schemasTypeLiteral.members.find(
      m => ts.isPropertySignature(m) && (m.name as ts.Identifier).text === name
    ) as ts.PropertySignature | undefined;

    if (!payloadProp || !ts.isTypeLiteralNode(payloadProp.type!)) {
      return yield* Effect.fail(
        new GenerateTypeFromJsonSchemaError({
          message: `Failed to find type literal for ${name}`,
        })
      );
    }

    const payloadTypeLiteral = payloadProp.type;

    // Print the type as a string with JSDoc preserved
    const printer = ts.createPrinter({ removeComments: false });

    const printedType = ts.factory.createTypeAliasDeclaration(
      [],
      // [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],
      name,
      undefined,
      payloadTypeLiteral
    );

    const printedText = printer.printNode(ts.EmitHint.Unspecified, printedType, sourceFile);

    // Formats the type so that it is indented by 2 spaces instead of 4
    const adjustedText = printedText.replace(/^ {4}/gm, '  ');

    return adjustedText;
  });
}

function isInterfaceComponents(node: ts.Node): node is ts.InterfaceDeclaration {
  return ts.isInterfaceDeclaration(node) && node.name.escapedText === 'components';
}
