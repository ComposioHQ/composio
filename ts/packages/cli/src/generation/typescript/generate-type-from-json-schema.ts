import ts from 'typescript';
import openapiTS, { type OpenAPI3, astToString } from 'openapi-typescript';
import { Effect } from 'effect';
import { TaggedError } from 'effect/Data';

export class GenerateTypeFromJsonSchemaError extends TaggedError('json-parsing-error')<{
  cause?: unknown;
  message?: string;
}> {}

export function generateTypeFromJsonSchema(
  name: string,
  schema: { readonly [x: string]: unknown }
) {
  // Preprocess the schema to remove discriminator objects that reference non-existent $defs.
  // The Composio API returns schemas with discriminator.mapping that point to #/$defs/... paths,
  // but the actual types are inlined in oneOf/anyOf arrays. openapi-typescript can handle
  // oneOf/anyOf without discriminator, so we simply remove it.
  const processedProperties = removeDiscriminators(schema['properties']);

  const openApi3Definition = {
    openapi: '3.1.0',
    components: {
      schemas: {
        [name]: {
          type: 'object',
          properties: processedProperties,
        },
      },
    },
  } as unknown as OpenAPI3;

  return Effect.gen(function* () {
    const astNodes = yield* Effect.tryPromise({
      try: () => openapiTS(openApi3Definition),
      catch: e =>
        new GenerateTypeFromJsonSchemaError({
          cause: e,
          message: 'Failed to generate type from JSON schema',
        }),
    });

    const components = astNodes.find(isInterfaceComponents);

    if (components === undefined) {
      return yield* Effect.fail(
        new GenerateTypeFromJsonSchemaError({
          message:
            'Failed to find `components` interface in types generated by `openapi-typescript`',
        })
      );
    }

    // This is the TypeScript definition obtained via `openapi-typescript`, which contains the types we want + some garbage we don't need.
    // We thus have to extract the type we want using the TypeScript API.
    const sourceCode = astToString(components);

    const sourceFile = ts.createSourceFile('virtual.ts', sourceCode, ts.ScriptTarget.Latest, true);

    // Navigate to components.schemas[name]
    const schemasProp = components.members.find(
      m => ts.isPropertySignature(m) && (m.name as ts.Identifier).text === 'schemas'
    ) as ts.PropertySignature | undefined;

    if (!schemasProp || !schemasProp.type || !ts.isTypeLiteralNode(schemasProp.type)) {
      return yield* Effect.fail(
        new GenerateTypeFromJsonSchemaError({
          message: '`schemas` is not a type literal',
        })
      );
    }

    const schemasTypeLiteral = schemasProp.type;
    const payloadProp = schemasTypeLiteral.members.find(
      m => ts.isPropertySignature(m) && (m.name as ts.Identifier).text === name
    ) as ts.PropertySignature | undefined;

    if (!payloadProp || !payloadProp.type) {
      return yield* Effect.fail(
        new GenerateTypeFromJsonSchemaError({
          message: `Failed to find type for ${name}`,
        })
      );
    }

    let typeNode: ts.TypeNode;

    // Handle different type node cases
    if (ts.isTypeLiteralNode(payloadProp.type)) {
      // Case 1: Type literal with specific properties (e.g., { foo: string; bar: number; })
      // BUT also handle empty type literals (which represent generic objects with no properties)
      if (payloadProp.type.members.length === 0) {
        // Empty type literal {} should be converted to 'object'
        typeNode = ts.factory.createTypeReferenceNode('object');
      } else {
        // Type literal with specific properties
        typeNode = payloadProp.type;
      }
    } else if (
      ts.isTypeReferenceNode(payloadProp.type) &&
      payloadProp.type.typeName &&
      ts.isIdentifier(payloadProp.type.typeName)
    ) {
      const typeNameText = payloadProp.type.typeName.text;
      if (typeNameText === 'object') {
        // Case 2a: Generic 'object' type reference - output TypeScript 'object' type
        typeNode = ts.factory.createTypeReferenceNode('object');
      } else if (typeNameText === 'Record') {
        // Case 2b: Record type (generated by openapi-typescript for generic objects) - convert to 'object'
        typeNode = ts.factory.createTypeReferenceNode('object');
      } else {
        // Case 2c: Other type references - fall back to 'unknown'
        typeNode = ts.factory.createTypeReferenceNode('unknown');
      }
    } else if (
      ts.isToken(payloadProp.type) &&
      payloadProp.type.kind === ts.SyntaxKind.ObjectKeyword
    ) {
      // Case 3: Direct 'object' keyword - output TypeScript 'object' type
      typeNode = ts.factory.createTypeReferenceNode('object');
    } else {
      // Case 4: Other unexpected types - fall back to 'unknown'
      typeNode = ts.factory.createTypeReferenceNode('unknown');
    }

    // Print the type as a string with JSDoc preserved
    const printer = ts.createPrinter({ removeComments: false });

    const printedType = ts.factory.createTypeAliasDeclaration(
      [],
      // [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],
      name,
      undefined,
      typeNode
    );

    const printedText = printer.printNode(ts.EmitHint.Unspecified, printedType, sourceFile);

    // Formats the type so that it is indented by 2 spaces instead of 4
    const adjustedText = printedText.replace(/^ {4}/gm, '  ');

    return adjustedText;
  });
}

function isInterfaceComponents(node: ts.Node): node is ts.InterfaceDeclaration {
  return ts.isInterfaceDeclaration(node) && node.name.escapedText === 'components';
}

/**
 * Recursively removes OpenAPI `discriminator` objects from a JSON schema.
 * This is needed because Composio's API returns schemas with discriminator.mapping
 * that reference #/$defs/... paths, but the types are inlined in oneOf/anyOf arrays
 * rather than defined in a $defs section. openapi-typescript fails to resolve these refs.
 * Since oneOf/anyOf work fine without discriminator, we simply remove it.
 *
 * IMPORTANT: We only remove `discriminator` keys when the value is an actual OpenAPI
 * discriminator object (identified by having a `propertyName` field per the OpenAPI spec).
 * This avoids accidentally stripping user-defined properties that happen to be named "discriminator".
 */
function removeDiscriminators(obj: unknown): unknown {
  if (obj === null || typeof obj !== 'object') {
    return obj;
  }

  if (Array.isArray(obj)) {
    return obj.map(removeDiscriminators);
  }

  const result: Record<string, unknown> = {};
  for (const [key, value] of Object.entries(obj)) {
    if (key === 'discriminator' && isOpenApiDiscriminator(value)) {
      // Skip OpenAPI discriminator objects (must have `propertyName` per spec)
      continue;
    }
    result[key] = removeDiscriminators(value);
  }
  return result;
}

/**
 * Checks if a value is an OpenAPI discriminator object.
 * Per the OpenAPI 3.0/3.1 spec, a discriminator object MUST have a `propertyName` field.
 * @see https://spec.openapis.org/oas/v3.1.0#discriminator-object
 */
function isOpenApiDiscriminator(value: unknown): boolean {
  return (
    value !== null &&
    typeof value === 'object' &&
    !Array.isArray(value) &&
    'propertyName' in value &&
    typeof (value as Record<string, unknown>)['propertyName'] === 'string'
  );
}
