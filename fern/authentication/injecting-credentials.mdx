---
title: 'Injecting Custom Credentials'
subtitle: 'Execute actions using authentication tokens or keys provided at runtime'
---

While Composio excels at managing user connections via [Integrations](/auth/integrations) and the [connection flow](/auth/connecting-users), there are scenarios where you might need to provide authentication credentials **directly** when executing an action. This bypasses Composio's stored Connections entirely.

**Use Cases:**

*   You manage API keys or tokens completely outside of Composio (e.g., in your own secure vault).
*   You obtain short-lived or temporary credentials specific to a single request.
*   You need to override the stored connection for a specific API call during testing or debugging.

This is achieved using the `auth` parameter within the `execute_action` method.

## The `auth` Parameter in `execute_action`

When calling `execute_action`, you can include an `auth` object (Python `dict` / TS `object`) to specify the credentials Composio should use for that specific API call. This overrides any attempt Composio would normally make to look up credentials based on `entity_id` or `connected_account_id`.

The core of the `auth` object is the `parameters` list, which defines the credentials and how they should be injected into the API request.

**`CustomAuthParameter` Structure:**

Each item in the `parameters` list should be an object with:

*   `name`: (`str`) The name of the credential parameter (e.g., `"Authorization"`, `"X-Api-Key"`, `"api_key"`).
*   `value`: (`str`) The actual secret value (e.g., `"Bearer xyz..."`, `"sk-abc..."`).
*   `in_` (Python) / `in` (TS): (`str` or `ParamPlacement`) Where to place the parameter in the HTTP request. Common values include:
    *   `"header"` / `ParamPlacement.Header`: In the request headers.
    *   `"query"` / `ParamPlacement.Query`: As a URL query parameter.
    *   `"path"` / `ParamPlacement.Path`: As part of the URL path (less common for auth).
    *   `"subdomain"` / `ParamPlacement.Subdomain`: As part of the subdomain.

*(Optional fields like `base_url` and `body` can also exist within the top-level `auth` object for very specific authentication schemes, but `parameters` is the most common.)*

## Examples

### Example 1: Using a Bearer Token (Header)

This is common for many modern APIs.

<CodeGroup>
```python Python
from composio import ComposioToolSet, Action

toolset = ComposioToolSet()
# Assume this token was obtained externally
my_bearer_token = "ghp_YourExternallyManagedGitHubToken..."

try:
    result = toolset.execute_action(
        action=Action.GITHUB_GET_THE_AUTHENTICATED_USER, # Example action
        params={},
        auth={
            "parameters": [
                {
                    "name": "Authorization",
                    "value": f"Bearer {my_bearer_token}",
                    "in_": "header" # Inject as Authorization header
                }
            ]
        }
    )
    print("Executed with custom Bearer token:", result)
except Exception as e:
    print(f"Error: {e}")
```
```typescript TypeScript
import { ComposioToolSet, Action, ParamPlacement } from "composio-core";

const toolset = new ComposioToolSet();
// Assume this token was obtained externally
const myBearerToken = "ghp_YourExternallyManagedGitHubToken...";

async function executeWithBearer() {
    try {
        const result = await toolset.executeAction({
            action: Action.GITHUB_GET_THE_AUTHENTICATED_USER, // Example action
            params: {},
            auth: {
                parameters: [
                    {
                        name: "Authorization",
                        value: `Bearer ${myBearerToken}`,
                        in: ParamPlacement.Header // Inject as Authorization header
                    }
                ]
            }
        });
        console.log("Executed with custom Bearer token:", result);
    } catch (error) {
        console.error("Error:", error);
    }
}

executeWithBearer();
```
</CodeGroup>

### Example 2: Using an API Key (Custom Header)

Some services use custom header names like `X-Api-Key`.

<CodeGroup>
```python Python
from composio import ComposioToolSet, Action

toolset = ComposioToolSet()
my_service_api_key = "sk_live_YourServiceKey..."

try:
    result = toolset.execute_action(
        action="SOME_SERVICE_ACTION", # Replace with actual action
        params={"some_param": "value"},
        auth={
            "parameters": [
                {
                    "name": "X-Api-Key", # Custom header name
                    "value": my_service_api_key,
                    "in_": "header"
                }
            ]
        }
    )
    print("Executed with custom X-Api-Key header:", result)
except Exception as e:
    print(f"Error: {e}")
```
```typescript TypeScript
import { ComposioToolSet, Action, ParamPlacement } from "composio-core";

const toolset = new ComposioToolSet();
const myServiceApiKey = "sk_live_YourServiceKey...";

async function executeWithHeaderKey() {
    try {
        const result = await toolset.executeAction({
            action: "SOME_SERVICE_ACTION", // Replace with actual action
            params: { some_param: "value" },
            auth: {
                parameters: [
                    {
                        name: "X-Api-Key", // Custom header name
                        value: myServiceApiKey,
                        in: ParamPlacement.Header
                    }
                ]
            }
        });
        console.log("Executed with custom X-Api-Key header:", result);
    } catch (error) {
        console.error("Error:", error);
    }
}

executeWithHeaderKey();
```
</CodeGroup>

### Example 3: Using an API Key (Query Parameter)

Sometimes keys are passed in the URL, like `https://api.service.com/data?apiKey=...`.

<CodeGroup>
```python Python
from composio import ComposioToolSet, Action

toolset = ComposioToolSet()
my_query_api_key = "querykey_abc123..."

try:
    result = toolset.execute_action(
        action="ANOTHER_SERVICE_ACTION", # Replace with actual action
        params={"resource_id": "res-456"},
        auth={
            "parameters": [
                {
                    "name": "apiKey", # Name of the query parameter
                    "value": my_query_api_key,
                    "in_": "query" # Inject as URL query parameter
                }
            ]
        }
    )
    print("Executed with custom query API key:", result)
except Exception as e:
    print(f"Error: {e}")
```
```typescript TypeScript
import { ComposioToolSet, Action, ParamPlacement } from "composio-core";

const toolset = new ComposioToolSet();
const myQueryApiKey = "querykey_abc123...";

async function executeWithQueryKey() {
    try {
        const result = await toolset.executeAction({
            action: "ANOTHER_SERVICE_ACTION", // Replace with actual action
            params: { resource_id: "res-456" },
            auth: {
                parameters: [
                    {
                        name: "apiKey", // Name of the query parameter
                        value: myQueryApiKey,
                        in: ParamPlacement.Query // Inject as URL query parameter
                    }
                ]
            }
        });
        console.log("Executed with custom query API key:", result);
    } catch (error) {
        console.error("Error:", error);
    }
}

executeWithQueryKey();
```
</CodeGroup>

<Note title="Context Parameters">
When using the `auth` parameter to provide runtime credentials, you typically do **not** need to specify `entity_id` or `connected_account_id`, as the provided `auth` object fully defines the authentication for that specific call.
</Note>

This method offers maximum flexibility for scenarios where you manage credentials outside of Composio's standard connection lifecycle.
