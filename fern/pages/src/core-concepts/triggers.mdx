---
title: Triggers
subtitle: Understanding the triggers in Composio
image: 'https://og.composio.dev/api/og?title=Triggers' # image for socials
keywords: ''
hide-nav-links: false
---

Triggers enable your applications to respond to real-time events from external services. Instead of polling for changes, triggers deliver events instantly when they occur.

## What Are Triggers?

A **Trigger** is a real-time event notification from an external service. When something happens in a connected service (like a new email, GitHub issue, or Slack message), Composio delivers that event to your application.

<CodeGroup>

```python
# Create a trigger for new GitHub issues
trigger = await composio.triggers.create(
    user_id='user_123',
    trigger_slug='GITHUB_ISSUE_CREATED',
    trigger_config={
        'repository': 'composiohq/composio'
    }
)
```
```typescript
// Create a trigger for new GitHub issues
const trigger = await composio.triggers.create(
  'user_123',
  'GITHUB_ISSUE_CREATED',
  {
    triggerConfig: {
      repository: 'composiohq/composio'
    }
  }
);
```

</CodeGroup>

## How Triggers Work

1. **Create**: Set up a trigger for specific events
2. **Connect**: User authorizes the external service
3. **Monitor**: Composio watches for events in real-time
4. **Deliver**: Events are sent to your application via webhooks or SDK

## Development vs Production

### Development: SDK Subscription
For testing and development, subscribe to events in your code:

<CodeGroup>


```python
# Development only - not for production
def handle_event(trigger_data):
    print(f"Event: {trigger_data.trigger_slug}")
    print(f"Data: {trigger_data.payload}")

composio.triggers.subscribe(
    callback=handle_event,
    filters={'user_id': 'user_123'}
)
```
```typescript
// Development only - not for production
composio.triggers.subscribe((triggerData) => {
  console.log(`Event: ${triggerData.triggerSlug}`);
  console.log(`Data: ${triggerData.payload}`);
}, {
  userId: 'user_123'
});
```
</CodeGroup>

### Production: Webhook Endpoints
For production, use webhook endpoints to receive events:

<CodeGroup>
```python Python
# Production webhook endpoint
@app.route('/webhooks/composio', methods=['POST'])
def handle_webhook():
    trigger_data = request.json
    
    # Process the event
    process_event(trigger_data)
    
    return jsonify({'status': 'success'}), 200
```

```typescript TypeScript
// Production webhook endpoint
app.post('/webhooks/composio', (req, res) => {
  const triggerData = req.body;
  
  // Process the event
  processEvent(triggerData);
  
  res.status(200).json({ status: 'success' });
});
```
</CodeGroup>

## Event Structure

All trigger events follow a consistent format:

<CodeGroup>
```python Python
# Trigger event structure
{
    'id': 'trigger_instance_id',
    'trigger_slug': 'GITHUB_ISSUE_CREATED',
    'toolkit_slug': 'github',
    'user_id': 'user_123',
    'payload': {
        # Event-specific data
        'title': 'Bug Report',
        'number': 42,
        'author': 'username'
    },
    'metadata': {
        'connected_account': {
            'id': 'ca_abc123',
            'status': 'ACTIVE'
        }
    }
}
```

```typescript TypeScript
// Trigger event structure
interface TriggerEvent {
  id: string;                    // Trigger instance ID
  triggerSlug: string;           // Event type
  toolkitSlug: string;           // Service name
  userId: string;                // User ID
  payload: {                     // Event data
    title: string;
    number: number;
    author: string;
  };
  metadata: {
    connectedAccount: {
      id: string;                // Connected account ID
      status: string;            // Connection status
    };
  };
}
```
</CodeGroup>

## Managing Triggers

### List Active Triggers
<CodeGroup>


```python
# Get all active triggers
triggers = await composio.triggers.list_active()

# Filter by user or toolkit
user_triggers = await composio.triggers.list_active(
    filters={'user_ids': ['user_123']}
)
```
```typescript
// Get all active triggers
const triggers = await composio.triggers.listActive();

// Filter by user or toolkit
const userTriggers = await composio.triggers.listActive({
  connectedAccountIds: ['ca_123']
});
```
</CodeGroup>

### Enable/Disable Triggers
<CodeGroup>


```python
# Temporarily disable a trigger
await composio.triggers.disable('trigger_id')

# Re-enable when needed
await composio.triggers.enable('trigger_id')
```
```typescript
// Temporarily disable a trigger
await composio.triggers.disable('trigger_id');

// Re-enable when needed
await composio.triggers.enable('trigger_id');
```
</CodeGroup>

## Key Differences: Development vs Production

| Aspect | Development (SDK) | Production (Webhooks) |
|--------|------------------|----------------------|
| **Connection** | Persistent WebSocket | HTTP requests |
| **Scalability** | Single instance | Horizontally scalable |
| **Reliability** | Can disconnect | Built-in retries |
| **Deployment** | Not recommended | Production-ready |

## Best Practices

### For Development
- Use `triggers.subscribe()` for quick testing
- Monitor connection status during development
- Handle events synchronously for debugging

### For Production
- Always use webhook endpoints
- Implement signature verification for security
- Handle duplicate events (idempotency)
- Use proper HTTP status codes (200 for success)
- Implement retry logic for failed processing

### General Guidelines
- Filter events to reduce unnecessary processing
- Monitor trigger health and connection status
- Handle connection failures gracefully
- Log events for debugging and monitoring

---

Triggers enable reactive applications that respond immediately to external events, creating more efficient and responsive integrations.