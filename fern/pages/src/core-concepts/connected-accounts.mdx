---
title: Connected Accounts
subtitle: Understanding the connected accounts in Composio
image: 'https://og.composio.dev/api/og?title=Connected%20Accounts' # image for socials
keywords: ''
hide-nav-links: true
---
Connected Accounts represent a user's authorized connection to an external service. They store authentication tokens and credentials needed to execute tools on behalf of the user.

## What Are Connected Accounts?

A Connected Account is created when a user authorizes your application to access their external service account (like GitHub, Gmail, or Slack). It acts as a secure bridge between your application and the external service.

<CodeGroup>
```python
# A connected account enables tool execution
result = await composio.tools.execute('GITHUB_GET_REPO',
    user_id='user_123',
    connected_account_id='ca_abc123',  # References the connected account
    arguments={'owner': 'composio', 'repo': 'sdk'}
)
```
```typescript
// A connected account enables tool execution
const result = await composio.tools.execute('GITHUB_GET_REPO', {
  userId: 'user_123',
  connectedAccountId: 'ca_abc123', // References the connected account
  arguments: { owner: 'composio', repo: 'sdk' }
});
```

</CodeGroup>

## The Connection Flow

### 1. Initiate Connection
Start the authorization process for a user and toolkit:

<CodeGroup>
```python
connection_request = await composio.toolkits.authorize(
    'user_123',  # Your user's ID
    'github'     # Toolkit to connect
)

print('Redirect user to:', connection_request.redirect_url)
```
```typescript
const connectionRequest = await composio.toolkits.authorize(
  'user_123',  // Your user's ID
  'github'     // Toolkit to connect
);

console.log('Redirect user to:', connectionRequest.redirectUrl);
```

</CodeGroup>

If your want to use a specific auth config, you can do so by passing the auth config ID to the `initiate` method:

<CodeGroup>
```python Python
connection_request = await composio.connected_accounts.initiate(
    'user_123',
    'ac_123322'  # Auth config ID to connect
)
```

```typescript TypeScript
const connectionRequest = await composio.connectedAccounts.initiate(
  'user_123',
  'ac_123322' // Auth config ID to connect
);
```
</CodeGroup>

### 2. User Authorization
The user visits the redirect URL and authorizes access through the external service (OAuth flow).

### 3. Connection Completion
Wait for the user to complete authorization:

<CodeGroup>
```python Python
connected_account = await connection_request.wait_for_connection(
    120000  # 2 minutes timeout
)

print('Connected account ID:', connected_account.id)
```

```typescript TypeScript
const connectedAccount = await connectionRequest.waitForConnection(
  120000 // 2 minutes timeout
);

console.log('Connected account ID:', connectedAccount.id);
```
</CodeGroup>

### 4. Use Connected Account
Execute tools using the connected account:

<CodeGroup>
```python Python
repos = await composio.tools.execute('GITHUB_LIST_REPOS',
    user_id='user_123',
    connected_account_id=connected_account.id,
    arguments={'per_page': 10}
)
```

```typescript TypeScript
const repos = await composio.tools.execute('GITHUB_LIST_REPOS', {
  userId: 'user_123',
  connectedAccountId: connectedAccount.id,
  arguments: { per_page: 10 }
});
```
</CodeGroup>

## Authentication Schemes

Connected accounts support different authentication methods:

### OAuth2 (Most Common)
<CodeGroup>
```python
# OAuth2 flow - user authorizes in browser
connection_request = await composio.toolkits.authorize('user_123', 'github')
#-- or use connected_accounts.initiate for specific auth config
connection_request = await composio.connected_accounts.initiate('user_123', 'ac_123322')

# use the redirect_url to redirect the user to the auth flow
print(connection_request.redirect_url)

# User completes OAuth flow at connection.redirect_url
connected_account = await connection_request.wait_for_connection()
```
```typescript
// OAuth2 flow - user authorizes in browser
const connectionRequest = await composio.toolkits.authorize('user_123', 'github');
//-- or use connectedAccounts.initiate for specific auth config
const connectionRequest = await composio.connectedAccounts.initiate('user_123', 'ac_123322');

// use the redirectUrl to redirect the user to the auth flow
console.log(connectionRequest.redirectUrl);

// User completes OAuth flow at connection.redirectUrl
const connectedAccount = await connectionRequest.waitForConnection();
```

</CodeGroup>

### API Keys
<CodeGroup>

```python
# User provides their API key
connection = await composio.connected_accounts.initiate(
    'user_123',
    'auth_config_id',
    config=AuthScheme.api_key(
        api_key='user_provided_key'
    )
)
```

```typescript
// User provides their API key
const connection = await composio.connectedAccounts.initiate(
  'user_123',
  'auth_config_id',
  {
    config: AuthScheme.ApiKey({
      api_key: 'user_provided_key'
    })
  }
);
```


</CodeGroup>

### Basic Authentication
<CodeGroup>


```python
# Username and password
connection = await composio.connected_accounts.initiate(
    'user_123',
    'auth_config_id',
    config=AuthScheme.basic(
        username='user_name',
        password='user_password'
    )
)
```
```typescript
// Username and password
const connection = await composio.connectedAccounts.initiate(
  'user_123',
  'auth_config_id',
  {
    config: AuthScheme.Basic({
      username: 'user_name',
      password: 'user_password'
    })
  }
);
```
</CodeGroup>

### Bearer Tokens
<CodeGroup>

```python
# Bearer token authentication
connection = await composio.connected_accounts.initiate(
    'user_123',
    'auth_config_id',
    config=AuthScheme.bearer_token(
        token='bearer_token_value'
    )
)
```
```typescript
// Bearer token authentication
const connection = await composio.connectedAccounts.initiate(
  'user_123',
  'auth_config_id',
  {
    config: AuthScheme.BearerToken({
      token: 'bearer_token_value'
    })
  }
);
```

</CodeGroup>

## Managing Connected Accounts

### List User's Connections
<CodeGroup>


```python
# Get all connected accounts for a user
accounts = await composio.connected_accounts.list(
    user_ids=['user_123']
)

# Filter by specific toolkit
github_accounts = await composio.connected_accounts.list(
    user_ids=['user_123'],
    toolkit_slugs=['github']
)
```
```typescript
// Get all connected accounts for a user
const accounts = await composio.connectedAccounts.list({
  userIds: ['user_123']
});

// Filter by specific toolkit
const githubAccounts = await composio.connectedAccounts.list({
  userIds: ['user_123'],
  toolkitSlugs: ['github']
});
```
</CodeGroup>

### Check Connection Status
<CodeGroup>

```python
account = await composio.connected_accounts.get('ca_abc123')

print('Status:', account.status)  # 'ACTIVE', 'PENDING', 'EXPIRED'
print('Toolkit:', account.toolkit.slug)
print('User:', account.user_id)
```
```typescript
const account = await composio.connectedAccounts.get('ca_abc123');

console.log('Status:', account.status); // 'ACTIVE', 'PENDING', 'EXPIRED'
console.log('Toolkit:', account.toolkit.slug);
console.log('User:', account.userId);
```

</CodeGroup>

### Disable/Enable Connections
<CodeGroup>

```python
# Temporarily disable a connection
await composio.connected_accounts.disable('ca_abc123')

# Re-enable when needed
await composio.connected_accounts.enable('ca_abc123')
```
```typescript
// Temporarily disable a connection
await composio.connectedAccounts.disable('ca_abc123');

// Re-enable when needed
await composio.connectedAccounts.enable('ca_abc123');
```

</CodeGroup>

### Delete Connections
<CodeGroup>

```python
# Permanently remove a connection
await composio.connected_accounts.delete('ca_abc123')
```
```typescript
// Permanently remove a connection
await composio.connectedAccounts.delete('ca_abc123');
```

</CodeGroup>


## Multiple Accounts

By default, Composio prevents multiple connected accounts for the same toolkit to avoid conflicts. You can override this behavior:

<CodeGroup>

```python
# Allow multiple connections for the same toolkit
connection = await composio.connected_accounts.initiate(
    'user_123',
    'auth_config_id',
    allow_multiple=True
)
```
```typescript
// Allow multiple connections for the same toolkit
const connection = await composio.connectedAccounts.initiate(
  'user_123',
  'auth_config_id',
  {
    allowMultiple: true
  }
);
```
</CodeGroup>

**Use cases for multiple accounts:**
- User has multiple GitHub accounts (personal + work)
- Different email accounts for different purposes
- Separate accounts for different environments

## Error Handling

### Connection Timeout
<CodeGroup>

```python
try:
    account = await composio.connected_accounts.wait_for_connection(
        connection_id,
        300000  # 5 minutes
    )
except ConnectionRequestTimeoutError:
    print('User did not complete authorization in time')
```
```typescript
try {
  const account = await composio.connectedAccounts.waitForConnection(
    connectionId,
    300000 // 5 minutes
  );
} catch (error) {
  if (error instanceof ConnectionRequestTimeoutError) {
    console.log('User did not complete authorization in time');
  }
}
```

</CodeGroup>

### Connection Failed
<CodeGroup>


```python
try:
    account = await composio.connected_accounts.wait_for_connection(connection_id)
except ConnectionRequestFailedError:
    print('Authorization was denied or failed')
```
```typescript
try {
  const account = await composio.connectedAccounts.waitForConnection(connectionId);
} catch (error) {
  if (error instanceof ConnectionRequestFailedError) {
    console.log('Authorization was denied or failed');
  }
}
```
</CodeGroup>

### Missing Connected Account
<CodeGroup>

```python
try:
    result = await composio.tools.execute('GITHUB_GET_REPO',
        user_id='user_123',
        arguments={'owner': 'composio', 'repo': 'sdk'}
    )
except MissingConnectedAccountError:
    print('User needs to connect their GitHub account first')
```
```typescript
try {
  const result = await composio.tools.execute('GITHUB_GET_REPO', {
    userId: 'user_123',
    arguments: { owner: 'composio', repo: 'sdk' }
  });
} catch (error) {
  if (error instanceof MissingConnectedAccountError) {
    console.log('User needs to connect their GitHub account first');
  }
}
```

</CodeGroup>

## Best Practices

### Connection Management
<CodeGroup>


```python
# Check for existing connections before creating new ones
async def ensure_connection(user_id: str, toolkit: str):
    existing = await composio.connected_accounts.list(
        user_ids=[user_id],
        toolkit_slugs=[toolkit]
    )

    if len(existing.items) > 0 and existing.items[0].status == 'ACTIVE':
        return existing.items[0]

    # Create new connection
    connection = await composio.toolkits.authorize(user_id, toolkit)
    return await composio.connected_accounts.wait_for_connection(connection.id)
```
```typescript
// Check for existing connections before creating new ones
async function ensureConnection(userId: string, toolkit: string) {
  const existing = await composio.connectedAccounts.list({
    userIds: [userId],
    toolkitSlugs: [toolkit]
  });

  if (existing.items.length > 0 && existing.items[0].status === 'ACTIVE') {
    return existing.items[0];
  }

  // Create new connection
  const connection = await composio.toolkits.authorize(userId, toolkit);
  return await composio.connectedAccounts.waitForConnection(connection.id);
}
```
</CodeGroup>

### Graceful Degradation

<CodeGroup>


```python
# Handle missing connections gracefully
async def execute_with_fallback(user_id: str, tool_slug: str, args: dict):
    try:
        return await composio.tools.execute(tool_slug,
            user_id=user_id,
            arguments=args
        )
    except ComposioConnectedAccountNotFoundError:
        # Return connection URL instead of failing
        connection = await composio.toolkits.authorize(user_id, 'github')
        return {
            'requires_connection': True,
            'redirect_url': connection.redirect_url
        }
```
```typescript
// Handle missing connections gracefully
async function executeWithFallback(userId: string, toolSlug: string, args: Record<string, any>) {
  try {
    return await composio.tools.execute(toolSlug, {
      userId,
      arguments: args
    });
  } catch (error) {
    if (error instanceof ComposioConnectedAccountNotFoundError) {
      // Return connection URL instead of failing
      const connection = await composio.toolkits.authorize(userId, 'github');
      return {
        requiresConnection: true,
        redirectUrl: connection.redirectUrl
      };
    }
    throw error;
  }
}
```
</CodeGroup>

### Connection Health Monitoring

<CodeGroup>


```python
# Periodically check connection health
async def check_connection_health(user_id: str):
    accounts = await composio.connected_accounts.list(
        user_ids=[user_id]
    )

    unhealthy = [
        account for account in accounts.items
        if account.status != 'ACTIVE'
    ]

    if len(unhealthy) > 0:
        print(f"User {user_id} has {len(unhealthy)} unhealthy connections")
        # Notify user or attempt refresh
```
```typescript
// Periodically check connection health
async function checkConnectionHealth(userId: string) {
  const accounts = await composio.connectedAccounts.list({
    userIds: [userId]
  });

  const unhealthy = accounts.items.filter(
    account => account.status !== 'ACTIVE'
  );

  if (unhealthy.length > 0) {
    console.log(`User ${userId} has ${unhealthy.length} unhealthy connections`);
    // Notify user or attempt refresh
  }
}
```
</CodeGroup>

## Security Considerations

### Token Storage
Composio securely stores all authentication tokens. You never need to handle sensitive credentials directly.

### Access Control
Connected accounts are scoped to specific users. One user cannot access another user's connected accounts.

### Token Refresh
Composio automatically handles token refresh for OAuth2 connections when possible.

### Secure Deletion
When a connected account is deleted, all associated tokens are securely removed.

## Troubleshooting

### Connection Stuck in PENDING
- Check if user completed the OAuth flow
- Verify the redirect URL is accessible
- Increase the timeout duration

### EXPIRED Connections
- Try refreshing the connection
- If refresh fails, user needs to reconnect

### Multiple Connections Not Working
- Ensure `allowMultiple: true` is set
- Check if the auth config supports multiple connections

---

Connected accounts are the bridge between your users and external services. Understanding how to create, manage, and use them effectively is crucial for building reliable integrations.