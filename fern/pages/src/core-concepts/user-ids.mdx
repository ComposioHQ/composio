---
title: User IDs - The Security Foundation
subtitle: Understanding the security foundation of Composio
image: 'https://og.composio.dev/api/og?title=User%20IDs' # image for socials
keywords: ''
hide-nav-links: true
---
User IDs are the **core foundation** of accessing and executing tools in Composio. Every tool execution, connection authorization, and account management operation requires a `userId` parameter that identifies which user's context the operation should be performed in.

## Why User IDs Are Critical

User IDs provide the fundamental security layer that ensures:

- **Data Isolation**: Users can only access their own connected accounts and data
- **Security Boundaries**: No unauthorized access to other users' external services
- **Multi-Tenancy**: Support for applications with multiple users
- **Compliance**: Meet data privacy and security requirements
- **Audit Trail**: Track which user performed which actions

<CodeGroup>
```python Python
# ✅ Each user operates in their own secure context
user_a_repos = composio.tools.execute('GITHUB_LIST_REPOS',
    user_id='user_a',  # User A's GitHub repositories
    arguments={}
)

user_b_repos = composio.tools.execute('GITHUB_LIST_REPOS',
    user_id='user_b',  # User B's GitHub repositories
    arguments={}
)

# User A cannot see User B's repositories, and vice versa
```

```typescript TypeScript
// ✅ Each user operates in their own secure context
const userARepos = await composio.tools.execute('GITHUB_LIST_REPOS', {
  userId: 'user_a',  // User A's GitHub repositories
  arguments: {}
});

const userBRepos = await composio.tools.execute('GITHUB_LIST_REPOS', {
  userId: 'user_b',  // User B's GitHub repositories  
  arguments: {}
});

// User A cannot see User B's repositories, and vice versa
```
</CodeGroup>

## Choosing the Right User ID

### ✅ **Recommended: Database Primary Key**

The best practice is to use your application's existing user identifier:

<CodeGroup>
```python Python
# Use your database user ID
user_id = user.id  # e.g., "550e8400-e29b-41d4-a716-446655440000"
user_id = user.uuid  # e.g., UUID from your user table
user_id = user.primary_key  # Any unique, stable identifier

tools = await composio.tools.get(user_id,
    toolkits=['github']
)
```

```typescript TypeScript
// Use your database user ID
const userId = user.id; // e.g., "550e8400-e29b-41d4-a716-446655440000"
const userId = user.uuid; // e.g., UUID from your user table
const userId = user.primaryKey; // Any unique, stable identifier

const tools = await composio.tools.get(userId, {
  toolkits: ['github']
});
```
</CodeGroup>

**Why Database IDs Are Best:**
- **Unique**: Guaranteed uniqueness in your system
- **Stable**: Won't change over time
- **Consistent**: Already used throughout your application
- **Secure**: Not guessable or enumerable

### ✅ **Acceptable: Unique Username/Identifier**

If you don't have database IDs, use unique, stable identifiers:

<CodeGroup>
```python Python
user_id = user.username  # e.g., "john_doe_123"
user_id = user.external_id  # e.g., "auth0|507f1f77bcf86cd799439011"
user_id = f"tenant_{tenant_id}_user_{user_index}"  # Custom format
```

```typescript TypeScript
const userId = user.username; // e.g., "john_doe_123"
const userId = user.externalId; // e.g., "auth0|507f1f77bcf86cd799439011"
const userId = `tenant_${tenantId}_user_${userIndex}`; // Custom format
```
</CodeGroup>

### ⚠️ **Avoid: Email Addresses**

While functional, email addresses can change and cause issues:

<CodeGroup>
```python Python
# Not recommended - emails can change
user_id = user.email  # e.g., "user@example.com"

# Better: Use a stable ID even if you display the email
user_id = user.id  # Your stable user ID
display_name = user.email  # For display purposes only
```

```typescript TypeScript
// Not recommended - emails can change
const userId = user.email; // e.g., "user@example.com"

// Better: Use a stable ID even if you display the email
const userId = user.id; // Your stable user ID
const displayName = user.email; // For display purposes only
```
</CodeGroup>

### ❌ **Never Use: Sensitive or Guessable Data**

<CodeGroup>
```python Python
# ❌ DON'T use sensitive information
user_id = user.ssn  # Social Security Number
user_id = user.credit_card_number  # Financial data

# ❌ DON'T use easily guessable patterns
user_id = "user1"  # Sequential numbers
user_id = "admin"  # Common names
```

```typescript TypeScript
// ❌ DON'T use sensitive information
const userId = user.ssn; // Social Security Number
const userId = user.creditCardNumber; // Financial data

// ❌ DON'T use easily guessable patterns
const userId = "user1"; // Sequential numbers
const userId = "admin"; // Common names
```
</CodeGroup>

## Organization-Based Applications

For applications where users belong to organizations and apps are connected at the **organization level**, use the **organization ID** as the `userId`:

### When to Use Organization IDs

Use organization IDs when:
- **Team/Organization tools**: Slack, Microsoft Teams, project management tools
- **Enterprise applications**: IT administrators connect apps for the whole organization
- **Shared resources**: Multiple users need access to the same connected accounts
- **Role-based access**: Permissions are managed at the organization level

### Implementation Pattern

<CodeGroup>
```python Python
# Organization-based approach
user_id = organization.id  # e.g., "org_550e8400-e29b-41d4-a716-446655440000"

# All users in the organization share the same connected accounts
tools = await composio.tools.get(user_id,
    toolkits=['slack', 'github']
)

# Execute tools in the organization context
result = await composio.tools.execute('SLACK_SEND_MESSAGE',
    user_id=user_id,  # Organization ID, not individual user ID
    arguments={
        'channel': '#general',
        'text': 'Hello from the team!'
    }
)
```

```typescript TypeScript
// Organization-based approach
const userId = organization.id; // e.g., "org_550e8400-e29b-41d4-a716-446655440000"

// All users in the organization share the same connected accounts
const tools = await composio.tools.get(userId, {
  toolkits: ['slack', 'github']
});

// Execute tools in the organization context
const result = await composio.tools.execute('SLACK_SEND_MESSAGE', {
  userId: userId, // Organization ID, not individual user ID
  arguments: {
    channel: '#general',
    text: 'Hello from the team!'
  }
});
```
</CodeGroup>

### Complete Organization Example

<CodeGroup>
```python Python
from composio import Composio

composio = Composio(
    api_key=os.environ.get('COMPOSIO_API_KEY')
)

# 1. Admin connects Slack for the entire organization
async def connect_organization_to_slack(organization_id: str, admin_user_id: str):
    # Use organization ID as user_id in Composio
    connection_request = await composio.toolkits.authorize(organization_id, 'slack')
    
    # Store the connection request for the admin to complete
    await store_connection_request(organization_id, admin_user_id, connection_request)
    
    return connection_request.redirect_url

# 2. Any user in the organization can use the connected tools
async def send_slack_message(organization_id: str, channel: str, message: str):
    return await composio.tools.execute('SLACK_SEND_MESSAGE',
        user_id=organization_id,  # Organization ID, not individual user ID
        arguments={
            'channel': channel,
            'text': message
        }
    )

# 3. Check if organization has required connections
async def get_organization_tools(organization_id: str):
    return await composio.tools.get(organization_id,
        toolkits=['slack', 'github', 'jira']
    )

# Usage in your API endpoint
@app.post('/api/slack/message')
async def send_message():
    channel = request.json['channel']
    message = request.json['message']
    organization_id = request.user.organization_id  # Get from your auth system

    # Verify user has permission to send messages for this organization
    if not await user_can_send_messages(request.user.id, organization_id):
        return jsonify({'error': 'Insufficient permissions'}), 403

    try:
        result = await send_slack_message(organization_id, channel, message)
        return jsonify(result.data)
    except Exception as error:
        return jsonify({'error': 'Failed to send message'}), 500
```

```typescript TypeScript
import { Composio } from '@composio/core';

const composio = new Composio({
  apiKey: process.env.COMPOSIO_API_KEY
});

// 1. Admin connects Slack for the entire organization
async function connectOrganizationToSlack(organizationId: string, adminUserId: string) {
  // Use organization ID as userId in Composio
  const connectionRequest = await composio.toolkits.authorize(organizationId, 'slack');
  
  // Store the connection request for the admin to complete
  await storeConnectionRequest(organizationId, adminUserId, connectionRequest);
  
  return connectionRequest.redirectUrl;
}

// 2. Any user in the organization can use the connected tools
async function sendSlackMessage(organizationId: string, channel: string, message: string) {
  return await composio.tools.execute('SLACK_SEND_MESSAGE', {
    userId: organizationId, // Organization ID, not individual user ID
    arguments: {
      channel: channel,
      text: message
    }
  });
}

// 3. Check if organization has required connections
async function getOrganizationTools(organizationId: string) {
  return await composio.tools.get(organizationId, {
    toolkits: ['slack', 'github', 'jira']
  });
}

// Usage in your API endpoint
app.post('/api/slack/message', async (req, res) => {
  const { channel, message } = req.body;
  const organizationId = req.user.organizationId; // Get from your auth system

  // Verify user has permission to send messages for this organization
  if (!(await userCanSendMessages(req.user.id, organizationId))) {
    return res.status(403).json({ error: 'Insufficient permissions' });
  }

  try {
    const result = await sendSlackMessage(organizationId, channel, message);
    res.json(result.data);
  } catch (error) {
    res.status(500).json({ error: 'Failed to send message' });
  }
});
```
</CodeGroup>

## 🚨 The `default` User ID

The `default` userId refers to the default account of your Composio project and should **only be used for**:

- **Testing and development** environments
- **Single-user applications** where external users don't connect their own accounts
- **Internal tools** where all operations are performed by your system
- **Learning and experimentation**

### When `default` is Appropriate

<CodeGroup>
```python Python
# ✅ Good uses for 'default'
# 1. Development and testing
if os.environ.get('NODE_ENV') == 'development':
    tools = await composio.tools.get('default', toolkits=['github'])

# 2. Single-user applications
single_user_app = await composio.tools.execute('HACKERNEWS_GET_USER',
    user_id='default',
    arguments={'user_id': 'pg'}
)

# 3. Internal automation scripts
internal_script = await composio.tools.execute('GITHUB_CREATE_ISSUE',
    user_id='default',
    arguments={}  # internal tool usage
)
```

```typescript TypeScript
// ✅ Good uses for 'default'
// 1. Development and testing
if (process.env.NODE_ENV === 'development') {
  const tools = await composio.tools.get('default', { toolkits: ['github'] });
}

// 2. Single-user applications
const singleUserApp = await composio.tools.execute('HACKERNEWS_GET_USER', {
  userId: 'default',
  arguments: { userId: 'pg' }
});

// 3. Internal automation scripts
const internalScript = await composio.tools.execute('GITHUB_CREATE_ISSUE', {
  userId: 'default',
  arguments: { /* internal tool usage */ }
});
```
</CodeGroup>

### When NOT to Use `default`

<CodeGroup>
```python Python
# ❌ NEVER use 'default' in production multi-user apps
@app.post('/api/github/repos')
async def list_repos():
    # This would expose other users' data!
    repos = await composio.tools.execute('GITHUB_LIST_REPOS',
        user_id='default',  # ❌ Wrong! Use request.user.id
        arguments={}
    )

# ❌ Don't use 'default' for user-specific operations
user_email = await composio.tools.execute('GMAIL_SEND_EMAIL',
    user_id='default',  # ❌ Wrong! This could send from wrong account
    arguments={
        'to': 'user@example.com',
        'subject': 'Personal message'
    }
)
```

```typescript TypeScript
// ❌ NEVER use 'default' in production multi-user apps
app.post('/api/github/repos', async (req, res) => {
  // This would expose other users' data!
  const repos = await composio.tools.execute('GITHUB_LIST_REPOS', {
    userId: 'default', // ❌ Wrong! Use req.user.id
    arguments: {}
  });
});

// ❌ Don't use 'default' for user-specific operations
const userEmail = await composio.tools.execute('GMAIL_SEND_EMAIL', {
  userId: 'default', // ❌ Wrong! This could send from wrong account
  arguments: {
    to: 'user@example.com',
    subject: 'Personal message'
  }
});
```
</CodeGroup>

## Security Best Practices

### 1. **Always Validate User IDs**

<CodeGroup>
```python Python
# ✅ Validate user IDs before using them
def validate_user_id(user_id: str, authenticated_user: Any) -> str:
    # Ensure the user can only access their own data
    if user_id != authenticated_user.id:
        raise ValueError('Unauthorized: Cannot access other user data')
    return user_id

@app.post('/api/tools/execute')
async def execute_tool():
    user_id = validate_user_id(request.json['user_id'], request.user)
```

```typescript TypeScript
// ✅ Validate user IDs before using them
function validateUserId(userId: string, authenticatedUser: any) {
  // Ensure the user can only access their own data
  if (userId !== authenticatedUser.id) {
    throw new Error('Unauthorized: Cannot access other user data');
  }
  return userId;
}

app.post('/api/tools/execute', async (req, res) => {
  const userId = validateUserId(req.body.userId, req.user);
  // ... proceed with execution
});
```
</CodeGroup>

### 2. **Integrate with Your Auth System**

<CodeGroup>
```python Python
# ✅ Integrate with your existing auth
def authenticate_user(request):
    token = request.headers.get('authorization')
    user = verify_jwt(token)
    
    if not user:
        return jsonify({'error': 'Unauthorized'}), 401
    
    request.user = user
    return None

@app.use('/api/composio')
def auth_middleware():
    return authenticate_user(request)

@app.post('/api/composio/execute')
async def execute_tool():
    # request.user is guaranteed to be authenticated
    result = await composio.tools.execute(request.json['tool_slug'],
        user_id=request.user.id,  # Use authenticated user's ID
        arguments=request.json['arguments']
    )
    
    return jsonify(result)
```

```typescript TypeScript
// ✅ Integrate with your existing auth
const authenticateUser = async (req, res, next) => {
  const token = req.headers.authorization;
  const user = await verifyJWT(token);
  
  if (!user) {
    return res.status(401).json({ error: 'Unauthorized' });
  }
  
  req.user = user;
  next();
};

app.use('/api/composio', authenticateUser);

app.post('/api/composio/execute', async (req, res) => {
  // req.user is guaranteed to be authenticated
  const result = await composio.tools.execute(req.body.toolSlug, {
    userId: req.user.id, // Use authenticated user's ID
    arguments: req.body.arguments
  });
  
  res.json(result);
});
```
</CodeGroup>

### 3. **Never Expose User IDs in Client Code**

<CodeGroup>
```python Python
# ❌ Don't expose user IDs to the client
client_config = {
    'user_id': user.id,  # ❌ Exposed to client
    'api_key': 'composio-key'  # ❌ Never expose API keys
}

# ✅ Keep user IDs on the server
@app.post('/api/user/tools')
async def get_user_tools():
    # User ID is determined server-side from authentication
    tools = await composio.tools.get(request.user.id, request.json['filters'])
    return jsonify(tools)
```

```typescript TypeScript
// ❌ Don't expose user IDs to the client
const clientConfig = {
  userId: user.id, // ❌ Exposed to client
  apiKey: 'composio-key' // ❌ Never expose API keys
};

// ✅ Keep user IDs on the server
app.post('/api/user/tools', async (req, res) => {
  // User ID is determined server-side from authentication
  const tools = await composio.tools.get(req.user.id, req.body.filters);
  res.json(tools);
});
```
</CodeGroup>

## Implementation Examples

### Express.js Application

<CodeGroup>
```python Python
from flask import Flask, request, jsonify
from composio import Composio

app = Flask(__name__)
composio = Composio(api_key=os.environ.get('COMPOSIO_API_KEY'))

# Middleware to ensure user authentication
def require_auth():
    if not request.user:
        return jsonify({'error': 'Authentication required'}), 401
    return None

# Get user's available tools
@app.route('/api/tools', methods=['GET'])
@require_auth
async def get_tools():
    try:
        tools = await composio.tools.get(request.user.id,
            toolkits=request.args.get('toolkits', '').split(',') if request.args.get('toolkits') else []
        )
        return jsonify(tools)
    except Exception as error:
        return jsonify({'error': str(error)}), 500

# Execute tool for user
@app.route('/api/tools/execute', methods=['POST'])
@require_auth
async def execute_tool():
    try:
        result = await composio.tools.execute(request.json['tool_slug'],
            user_id=request.user.id,  # Always use authenticated user's ID
            arguments=request.json['arguments'],
            connected_account_id=request.json.get('connected_account_id')
        )
        
        return jsonify(result)
    except Exception as error:
        return jsonify({'error': str(error)}), 500
```

```typescript TypeScript
import express from 'express';
import { Composio } from '@composio/core';

const app = express();
const composio = new Composio({ apiKey: process.env.COMPOSIO_API_KEY });

// Middleware to ensure user authentication
const requireAuth = (req, res, next) => {
  if (!req.user) {
    return res.status(401).json({ error: 'Authentication required' });
  }
  next();
};

// Get user's available tools
app.get('/api/tools', requireAuth, async (req, res) => {
  try {
    const tools = await composio.tools.get(req.user.id, {
      toolkits: req.query.toolkits?.split(',') || []
    });
    res.json(tools);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Execute tool for user
app.post('/api/tools/execute', requireAuth, async (req, res) => {
  try {
    const result = await composio.tools.execute(req.body.toolSlug, {
      userId: req.user.id, // Always use authenticated user's ID
      arguments: req.body.arguments,
      connectedAccountId: req.body.connectedAccountId
    });
    
    res.json(result);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});
```
</CodeGroup>

### Next.js API Routes

<CodeGroup>
```python Python
# pages/api/composio/tools.py
from fastapi import FastAPI, Depends, HTTPException
from composio import Composio
from auth import get_server_session

app = FastAPI()
composio = Composio(api_key=os.environ.get('COMPOSIO_API_KEY'))

async def get_session(request):
    session = await get_server_session(request)
    if not session or not session.user:
        raise HTTPException(status_code=401, detail='Unauthorized')
    return session

@app.get('/api/composio/tools')
async def handle_get(request, session = Depends(get_session)):
    try:
        tools = await composio.tools.get(session.user.id,
            toolkits=request.query_params.get('toolkits', '').split(',') if request.query_params.get('toolkits') else []
        )
        return tools
    except Exception as error:
        raise HTTPException(status_code=500, detail=str(error))

@app.post('/api/composio/tools')
async def handle_post(request, session = Depends(get_session)):
    try:
        result = await composio.tools.execute(request.json['tool_slug'],
            user_id=session.user.id,  # Use session user ID
            arguments=request.json['arguments']
        )
        return result
    except Exception as error:
        raise HTTPException(status_code=500, detail=str(error))
```

```typescript TypeScript
// pages/api/composio/tools.ts
import { Composio } from '@composio/core';
import { getServerSession } from 'next-auth';

const composio = new Composio({ apiKey: process.env.COMPOSIO_API_KEY });

export default async function handler(req, res) {
  // Get authenticated user from NextAuth
  const session = await getServerSession(req, res);
  
  if (!session?.user) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  if (req.method === 'GET') {
    try {
      const tools = await composio.tools.get(session.user.id, {
        toolkits: req.query.toolkits?.split(',') || []
      });
      res.json(tools);
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  }
  
  if (req.method === 'POST') {
    try {
      const result = await composio.tools.execute(req.body.toolSlug, {
        userId: session.user.id, // Use session user ID
        arguments: req.body.arguments
      });
      res.json(result);
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  }
}
```
</CodeGroup>

## Common Mistakes and Solutions

### Mistake 1: Using `default` in Production

<CodeGroup>
```python Python
# ❌ Wrong - using default in production
result = await composio.tools.execute('GMAIL_SEND_EMAIL',
    user_id='default',
    arguments={'to': 'user@example.com', 'subject': 'Test'}
)

# ✅ Correct - use actual user ID
result = await composio.tools.execute('GMAIL_SEND_EMAIL',
    user_id=request.user.id,
    arguments={'to': 'user@example.com', 'subject': 'Test'}
)
```

```typescript TypeScript
// ❌ Wrong - using default in production
const result = await composio.tools.execute('GMAIL_SEND_EMAIL', {
  userId: 'default',
  arguments: { to: 'user@example.com', subject: 'Test' }
});

// ✅ Correct - use actual user ID
const result = await composio.tools.execute('GMAIL_SEND_EMAIL', {
  userId: req.user.id,
  arguments: { to: 'user@example.com', subject: 'Test' }
});
```
</CodeGroup>

### Mistake 2: Trusting Client-Provided User IDs

<CodeGroup>
```python Python
# ❌ Wrong - trusting client data
@app.post('/api/execute')
async def execute():
    result = await composio.tools.execute(request.json['tool_slug'],
        user_id=request.json['user_id'],  # ❌ Client could provide any user ID!
        arguments=request.json['arguments']
    )

# ✅ Correct - use server-side authentication
@app.post('/api/execute')
@require_auth
async def execute():
    result = await composio.tools.execute(request.json['tool_slug'],
        user_id=request.user.id,  # ✅ From authenticated session
        arguments=request.json['arguments']
    )
```

```typescript TypeScript
// ❌ Wrong - trusting client data
app.post('/api/execute', (req, res) => {
  const result = await composio.tools.execute(req.body.toolSlug, {
    userId: req.body.userId, // ❌ Client could provide any user ID!
    arguments: req.body.arguments
  });
});

// ✅ Correct - use server-side authentication
app.post('/api/execute', requireAuth, (req, res) => {
  const result = await composio.tools.execute(req.body.toolSlug, {
    userId: req.user.id, // ✅ From authenticated session
    arguments: req.body.arguments
  });
});
```
</CodeGroup>

### Mistake 3: Inconsistent User ID Format

<CodeGroup>
```python Python
# ❌ Wrong - mixing different formats
user_id1 = user.email      # "user@example.com"
user_id2 = user.id         # "12345"
user_id3 = user.username   # "john_doe"

# ✅ Correct - consistent format throughout app
user_id = user.id  # Always use the same property
```

```typescript TypeScript
// ❌ Wrong - mixing different formats
const userId1 = user.email;      // "user@example.com"
const userId2 = user.id;         // "12345"
const userId3 = user.username;   // "john_doe"

// ✅ Correct - consistent format throughout app
const userId = user.id; // Always use the same property
```
</CodeGroup>

## User ID Patterns Summary

| Pattern | Use Case | Example | Security Level |
|---------|----------|---------|----------------|
| Database UUID | Production apps | `550e8400-e29b-41d4-a716-446655440000` | ✅ High |
| Username | Simple apps | `john_doe_123` | ✅ Medium |
| Organization ID | Enterprise | `org_acme_corp` | ✅ High |
| Email | Not recommended | `user@example.com` | ⚠️ Medium |
| `default` | Testing only | `default` | ❌ Low |

## Key Takeaways

1. **User IDs are the foundation** of Composio's security model
2. **Use your database primary keys** for best security and consistency
3. **Never use `default` in production** multi-user applications
4. **Always validate user IDs** against your authentication system
5. **Organization IDs** are perfect for enterprise/team applications
6. **Keep user IDs server-side** and never expose them to clients

---

**🔐 Remember**: User IDs are your security boundary. Get this right, and everything else becomes much easier and more secure.