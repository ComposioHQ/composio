# Consistent Error Response Structure

Tool execution errors now return a standardized response format across all failure types. Previously, the `data` field was empty on errorsâ€”now it always includes `status_code` and `message`, matching the structure of successful responses.

## What Changed

All error responses from tool execution now include:
- `data.status_code`: HTTP status code (or `null` for non-HTTP errors)
- `data.message`: Detailed error message
- `error`: Same detailed message at the top level

## Before vs After

**Previous error response:**
```json
{
  "data": {},
  "successfull": false,
  "error": "404 Client Error: Not Found for url: ...",
}
```

**New error response:**
```json
{
  "data": {
      "http_error": "404 Client Error: Not Found for url: ...",
      "status_code": 404,
      "message": "Resource not found: The requested item does not exist"
  },
  "successfull": false,
  "error": "Resource not found: The requested item does not exist",
}
```

## Why This Matters

- **Easier parsing**: Agents and code can reliably access error details from `data.message` without special-casing empty `data` objects
- **Better debugging**: Detailed error messages replace generic HTTP error strings
- **Consistent schema**: Same response shape whether the tool succeeds or fails

---

# Union Types Preserved in Schemas

Tool request and response schemas now preserve `anyOf` (Union types) instead of flattening them to a single type.

## What Changed

Previously, when a field had multiple possible types (e.g., `string | number | null`), the schema parser would discard all but the first type. Now the full `anyOf` array is retained, giving you accurate type information.

## Before vs After

**Previous (flattened, losing type info):**
```json
{
  "properties": {
    "value": {
      "type": "string",
      "nullable": true
    }
  }
}
```

**Now (Union types preserved):**
```json
{
  "properties": {
    "value": {
      "anyOf": [
        { "type": "string" },
        { "type": "integer" },
        { "type": "null" }
      ]
    }
  }
}
```

## Why This Matters

- **Accurate schemas**: LLMs and code generators see the full set of allowed types
- **Better validation**: Input validation can now correctly accept all valid types, not just the first one