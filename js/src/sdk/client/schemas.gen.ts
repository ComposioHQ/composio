// This file is auto-generated by @hey-api/openapi-ts

export const $MemberInfoResDTO = {
  properties: {
    id: {
      format: "uuid",
      type: "string",
      description: "The ID/UUID of the member.",
    },
    orgId: {
      format: "uuid",
      type: "string",
      description:
        "The ID/UUID of the organization to which the member belongs.",
    },
    email: {
      format: "email",
      type: "string",
      description: "The email address of the member.",
    },
    name: {
      type: "string",
      description: "The name of the member.",
    },
    role: {
      enum: ["admin", "developer"],
      type: "string",
      description: "The role of the member.",
    },
    metadata: {
      type: "object",
      description:
        "The metadata of the member. This store some additional information about the member.",
    },
    createdAt: {
      oneOf: [
        {
          format: "date",
          type: "string",
        },
        {
          format: "date-time",
          type: "string",
        },
      ],
      description: "The date and time when the member was created.",
    },
    updatedAt: {
      oneOf: [
        {
          format: "date",
          type: "string",
        },
        {
          format: "date-time",
          type: "string",
        },
      ],
      description: "The date and time when the member was last updated.",
    },
    deletedAt: {
      oneOf: [
        {
          format: "date",
          type: "string",
        },
        {
          format: "date-time",
          type: "string",
        },
      ],
      description: "The date and time when the member was deleted.",
    },
  },
  type: "object",
  required: ["id", "orgId", "email", "name", "role", "createdAt", "updatedAt"],
  description: "Team Member information",
} as const;

export const $HttpError = {
  properties: {
    status: {
      minLength: 1,
      type: "number",
      description: "HTTP status code",
    },
    message: {
      minLength: 1,
      type: "string",
      description: "Error message",
    },
    requestId: {
      type: "string",
      description:
        "Request ID, used for tracing the request. This is very helpful for internal teams to debug issues.",
    },
  },
  type: "object",
  required: ["status", "message", "requestId"],
} as const;

export const $BadRequestError = {
  properties: {
    details: {
      type: "object",
      description: "Additional arguments that caused the error",
    },
    type: {
      minLength: 1,
      type: "string",
      enum: ["BadRequestError"],
      description: "The type of error",
    },
    status: {
      minLength: 1,
      type: "number",
      description: "HTTP status code",
    },
    message: {
      minLength: 1,
      type: "string",
      description: "Error message",
    },
    requestId: {
      type: "string",
      description:
        "Request ID, used for tracing the request. This is very helpful for internal teams to debug issues.",
    },
  },
  type: "object",
  required: ["details", "type", "status", "message", "requestId"],
} as const;

export const $InternalServerError = {
  properties: {
    type: {
      minLength: 1,
      type: "string",
      enum: ["InternalServerError"],
      description: "The type of error",
    },
    status: {
      minLength: 1,
      type: "number",
      description: "HTTP status code",
    },
    message: {
      minLength: 1,
      type: "string",
      description: "Error message",
    },
    requestId: {
      type: "string",
      description:
        "Request ID, used for tracing the request. This is very helpful for internal teams to debug issues.",
    },
  },
  type: "object",
  required: ["type", "status", "message", "requestId"],
} as const;

export const $NotFoundError = {
  properties: {
    type: {
      minLength: 1,
      type: "string",
      enum: ["NotFoundError"],
      description: "The name of the operation that caused the error",
    },
    status: {
      minLength: 1,
      type: "number",
      description: "HTTP status code",
    },
    message: {
      minLength: 1,
      type: "string",
      description: "Error message",
    },
    requestId: {
      type: "string",
      description:
        "Request ID, used for tracing the request. This is very helpful for internal teams to debug issues.",
    },
  },
  type: "object",
  required: ["type", "status", "message", "requestId"],
} as const;

export const $NotFoundPlusSuggestionsError = {
  properties: {
    suggestions: {
      items: {
        type: "string",
      },
      type: "array",
      minLength: 1,
      description: "Suggestions for the user to fix the error",
    },
    status: {
      minLength: 1,
      type: "number",
      description: "HTTP status code",
    },
    message: {
      minLength: 1,
      type: "string",
      description: "Error message",
    },
    requestId: {
      type: "string",
      description:
        "Request ID, used for tracing the request. This is very helpful for internal teams to debug issues.",
    },
    type: {
      minLength: 1,
      type: "string",
      enum: ["NotFoundError"],
      description: "The name of the operation that caused the error",
    },
  },
  type: "object",
  required: ["suggestions", "status", "message", "requestId", "type"],
} as const;

export const $AppNotFoundError = {
  properties: {
    name: {
      minLength: 1,
      type: "string",
      enum: ["AppNotFoundError"],
      description: "The error name",
    },
    status: {
      minLength: 1,
      type: "number",
      description: "HTTP status code",
    },
    message: {
      minLength: 1,
      type: "string",
      description: "Error message",
    },
    requestId: {
      type: "string",
      description:
        "Request ID, used for tracing the request. This is very helpful for internal teams to debug issues.",
    },
    type: {
      minLength: 1,
      type: "string",
      enum: ["NotFoundError"],
      description: "The name of the operation that caused the error",
    },
  },
  type: "object",
  required: ["name", "status", "message", "requestId", "type"],
} as const;

export const $ProjectAlreadyExistsError = {
  properties: {
    name: {
      minLength: 1,
      type: "string",
      enum: ["ProjectAlreadyExistsError"],
      description: "The error name",
    },
    status: {
      minLength: 1,
      type: "number",
      description: "HTTP status code",
    },
    message: {
      minLength: 1,
      type: "string",
      description: "Error message",
    },
    requestId: {
      type: "string",
      description:
        "Request ID, used for tracing the request. This is very helpful for internal teams to debug issues.",
    },
    details: {
      type: "object",
      description: "Additional arguments that caused the error",
    },
    type: {
      minLength: 1,
      type: "string",
      enum: ["BadRequestError"],
      description: "The type of error",
    },
  },
  type: "object",
  required: ["name", "status", "message", "requestId", "details", "type"],
} as const;

export const $ProjectIdNotFoundError = {
  properties: {
    name: {
      minLength: 1,
      type: "string",
      enum: ["ProjectNotFoundError"],
      description: "The error name",
    },
    status: {
      minLength: 1,
      type: "number",
      description: "HTTP status code",
    },
    message: {
      minLength: 1,
      type: "string",
      description: "Error message",
    },
    requestId: {
      type: "string",
      description:
        "Request ID, used for tracing the request. This is very helpful for internal teams to debug issues.",
    },
    details: {
      type: "object",
      description: "Additional arguments that caused the error",
    },
    type: {
      minLength: 1,
      type: "string",
      enum: ["BadRequestError"],
      description: "The type of error",
    },
  },
  type: "object",
  required: ["name", "status", "message", "requestId", "details", "type"],
} as const;

export const $ApiKeyNotFoundError = {
  properties: {
    name: {
      minLength: 1,
      type: "string",
      enum: ["ApiKeyNotFoundError"],
      description: "The error name",
    },
    status: {
      minLength: 1,
      type: "number",
      description: "HTTP status code",
    },
    message: {
      minLength: 1,
      type: "string",
      description: "Error message",
    },
    requestId: {
      type: "string",
      description:
        "Request ID, used for tracing the request. This is very helpful for internal teams to debug issues.",
    },
  },
  type: "object",
  required: ["name", "status", "message", "requestId"],
} as const;

export const $DeleteFailedError = {
  properties: {
    name: {
      minLength: 1,
      type: "string",
      enum: ["DeleteFailedError"],
      description: "The error name",
    },
    status: {
      minLength: 1,
      type: "number",
      description: "HTTP status code",
    },
    message: {
      minLength: 1,
      type: "string",
      description: "Error message",
    },
    requestId: {
      type: "string",
      description:
        "Request ID, used for tracing the request. This is very helpful for internal teams to debug issues.",
    },
    type: {
      minLength: 1,
      type: "string",
      enum: ["InternalServerError"],
      description: "The type of error",
    },
  },
  type: "object",
  required: ["name", "status", "message", "requestId", "type"],
} as const;

export const $InvalidMagicLinkTokenError = {
  properties: {
    name: {
      minLength: 1,
      type: "string",
      enum: ["InvalidMagicLinkTokenError"],
      description: "The error name",
    },
    status: {
      minLength: 1,
      type: "number",
      description: "HTTP status code",
    },
    message: {
      minLength: 1,
      type: "string",
      description: "Error message",
    },
    requestId: {
      type: "string",
      description:
        "Request ID, used for tracing the request. This is very helpful for internal teams to debug issues.",
    },
    details: {
      type: "object",
      description: "Additional arguments that caused the error",
    },
    type: {
      minLength: 1,
      type: "string",
      enum: ["BadRequestError"],
      description: "The type of error",
    },
  },
  type: "object",
  required: ["name", "status", "message", "requestId", "details", "type"],
} as const;

export const $UserAlreadyExistError = {
  properties: {
    name: {
      minLength: 1,
      type: "string",
      enum: ["UserAlreadyExistError"],
      description: "The error name",
    },
    status: {
      minLength: 1,
      type: "number",
      description: "HTTP status code",
    },
    message: {
      minLength: 1,
      type: "string",
      description: "Error message",
    },
    requestId: {
      type: "string",
      description:
        "Request ID, used for tracing the request. This is very helpful for internal teams to debug issues.",
    },
    details: {
      type: "object",
      description: "Additional arguments that caused the error",
    },
    type: {
      minLength: 1,
      type: "string",
      enum: ["BadRequestError"],
      description: "The type of error",
    },
  },
  type: "object",
  required: ["name", "status", "message", "requestId", "details", "type"],
} as const;

export const $FetchTokenError = {
  properties: {
    name: {
      minLength: 1,
      type: "string",
      enum: ["FetchTokenError"],
      description: "The error name",
    },
    status: {
      minLength: 1,
      type: "number",
      description: "HTTP status code",
    },
    message: {
      minLength: 1,
      type: "string",
      description: "Error message",
    },
    requestId: {
      type: "string",
      description:
        "Request ID, used for tracing the request. This is very helpful for internal teams to debug issues.",
    },
  },
  type: "object",
  required: ["name", "status", "message", "requestId"],
} as const;

export const $MagicLinkResDTO = {
  properties: {
    status: {
      type: "string",
    },
  },
  type: "object",
  required: ["status"],
} as const;

export const $MagicLinkReqDTO = {
  properties: {
    email: {
      format: "email",
      type: "string",
      description: "The email of the user",
    },
    verifyHost: {
      type: "string",
      description: "The frontend host of the user",
    },
  },
  type: "object",
  required: ["email", "verifyHost"],
} as const;

export const $LogoutResDTO = {
  properties: {
    message: {
      type: "string",
      description: "Message confirming the logout",
    },
  },
  type: "object",
  required: ["message"],
} as const;

export const $VerifyMagicLinkReqDTO = {
  properties: {
    token: {
      type: "string",
      description: "The magic link token",
    },
  },
  type: "object",
  required: ["token"],
} as const;

export const $VerifyMagicLinkDataDTO = {
  properties: {
    clientId: {
      type: "string",
    },
    isValid: {
      type: "boolean",
    },
    jwtToken: {
      type: "string",
    },
    email: {
      type: "string",
      format: "email",
    },
  },
  type: "object",
  required: ["clientId", "isValid", "jwtToken", "email"],
  description:
    "Data containing client and token information if verification is successful",
} as const;

export const $VerifyMagicLinkResDTO = {
  properties: {
    message: {
      type: "string",
      description: "Message indicating the result of the verification",
    },
    data: {
      $ref: "#/components/schemas/VerifyMagicLinkDataDTO",
    },
  },
  type: "object",
  required: ["message"],
} as const;

export const $IdentifyClientReqDTO = {
  properties: {
    hash: {
      type: "string",
      description: "The hash of the client",
    },
    framework: {
      type: "string",
      description: "The framework used by the client",
    },
  },
  type: "object",
  required: ["hash"],
} as const;

export const $IdentifyClientResDTO = {
  properties: {
    clientId: {
      type: "string",
      description: "The client ID",
    },
    apiKey: {
      type: "string",
      description: "The API key associated with the client",
    },
    email: {
      type: "string",
      description: "The email associated with the client",
    },
    orgId: {
      type: "string",
      description: "The organization ID associated with the client",
    },
  },
  type: "object",
  required: ["clientId", "apiKey", "email", "orgId"],
} as const;

export const $UserGitUserInfo = {
  properties: {
    name: {
      type: "string",
    },
    email: {
      format: "email",
      type: "string",
    },
  },
  type: "object",
  required: ["email"],
  description: "User Git information",
} as const;

export const $TrackClientReqDTO = {
  properties: {
    framework: {
      type: "string",
      description: "The framework used by the client",
    },
    mac_address: {
      type: "string",
      description: "The MAC address of the client device",
    },
    user_git_user_info: {
      $ref: "#/components/schemas/UserGitUserInfo",
    },
  },
  type: "object",
  required: ["framework"],
} as const;

export const $TrackClientResDTO = {
  properties: {
    message: {
      type: "string",
      description: "Message indicating the result of the tracking operation",
    },
  },
  type: "object",
  required: ["message"],
} as const;

export const $DeleteRowAPIDTO = {
  properties: {
    status: {
      enum: ["success", "failed"],
      type: "string",
      description: "Status of the delete operation",
    },
    count: {
      type: "number",
      description: "Number of records deleted",
    },
  },
  type: "object",
  required: ["status", "count"],
} as const;

export const $ClientDTO = {
  properties: {
    autoId: {
      type: "number",
      description: "Auto-generated ID of the client",
    },
    id: {
      type: "string",
      description: "Unique ID of the client",
    },
    name: {
      type: "string",
      description: "Name of the client",
    },
    email: {
      type: "string",
      description: "Email of the client",
    },
    createdAt: {
      oneOf: [
        {
          format: "date",
          type: "string",
        },
        {
          format: "date-time",
          type: "string",
        },
      ],
      description: "Creation timestamp",
    },
    updatedAt: {
      oneOf: [
        {
          format: "date",
          type: "string",
        },
        {
          format: "date-time",
          type: "string",
        },
      ],
      description: "Last update timestamp",
    },
    apiKey: {
      type: "string",
      description: "API key for the client",
    },
    webhookURL: {
      type: "string",
      description: "Webhook URL for the client",
    },
    eventWebhookURL: {
      type: "string",
      description: "Event webhook URL for the client",
    },
    webhookSecret: {
      type: "string",
      description: "Secret for webhook authentication",
    },
    triggersEnabled: {
      type: "boolean",
      description: "Whether triggers are enabled for the client",
    },
    lastSubscribedAt: {
      oneOf: [
        {
          format: "date",
          type: "string",
        },
        {
          format: "date-time",
          type: "string",
        },
      ],
      description: "Last subscription timestamp",
    },
    plan: {
      type: "string",
      description: "Client's subscription plan",
    },
    isNewWebhook: {
      type: "boolean",
      description: "Whether to use new webhook format",
    },
  },
  type: "object",
  required: [
    "autoId",
    "id",
    "name",
    "email",
    "createdAt",
    "updatedAt",
    "triggersEnabled",
    "plan",
    "isNewWebhook",
  ],
  description: "Client information",
} as const;

export const $Metadata = {
  properties: {
    has_completed_onboarding: {
      type: "boolean",
      description: "Indicates if the member has completed onboarding",
    },
  },
  type: "object",
} as const;

export const $Member = {
  properties: {
    id: {
      type: "string",
      description: "Unique identifier for the member",
    },
    orgId: {
      type: "string",
      description: "Organization ID associated with the member",
    },
    name: {
      type: "string",
      description: "Name of the member",
    },
    role: {
      type: "string",
      description: "Role of the member",
    },
    createdAt: {
      oneOf: [
        {
          format: "date",
          type: "string",
        },
        {
          format: "date-time",
          type: "string",
        },
      ],
      description: "Creation timestamp of the member",
    },
    updatedAt: {
      oneOf: [
        {
          format: "date",
          type: "string",
        },
        {
          format: "date-time",
          type: "string",
        },
      ],
      description: "Last update timestamp of the member",
    },
    deletedAt: {
      oneOf: [
        {
          format: "date",
          type: "string",
        },
        {
          format: "date-time",
          type: "string",
        },
      ],
      description: "Deletion timestamp of the member, if applicable",
    },
  },
  type: "object",
  required: ["id", "orgId", "name", "role", "createdAt", "updatedAt"],
} as const;

export const $ClientInfoAPIKeyResDTO = {
  properties: {
    id: {
      type: "string",
      description: "Unique identifier for the API key",
    },
    name: {
      type: "string",
      description: "Name of the API key",
    },
    clientId: {
      type: "string",
      description: "Client ID associated with the API key",
    },
    memberId: {
      type: "string",
      description: "Member ID associated with the API key",
    },
    createdAt: {
      oneOf: [
        {
          format: "date",
          type: "string",
        },
        {
          format: "date-time",
          type: "string",
        },
      ],
      description: "Creation timestamp of the API key",
    },
    updatedAt: {
      oneOf: [
        {
          format: "date",
          type: "string",
        },
        {
          format: "date-time",
          type: "string",
        },
      ],
      description: "Last update timestamp of the API key",
    },
    deletedAt: {
      oneOf: [
        {
          format: "date",
          type: "string",
        },
        {
          format: "date-time",
          type: "string",
        },
      ],
      description: "Deletion timestamp of the API key, if applicable",
    },
    key: {
      type: "string",
      description: "Key value of the API key",
    },
    member: {
      $ref: "#/components/schemas/Member",
      description: "Member associated with the API key",
    },
    lastUsed: {
      oneOf: [
        {
          format: "date",
          type: "string",
        },
        {
          format: "date-time",
          type: "string",
        },
      ],
      description: "Last used timestamp of the API key",
    },
    apiKey: {
      type: "string",
      description: "API key of the client",
    },
  },
  type: "object",
  required: [
    "id",
    "name",
    "clientId",
    "memberId",
    "createdAt",
    "updatedAt",
    "key",
    "member",
    "lastUsed",
    "apiKey",
  ],
} as const;

export const $ClientInfoResDTO = {
  properties: {
    client: {
      $ref: "#/components/schemas/ClientDTO",
    },
    apiKey: {
      $ref: "#/components/schemas/ClientInfoAPIKeyResDTO",
      description: "API key of the client",
    },
  },
  type: "object",
  required: ["client", "apiKey"],
} as const;

export const $ProjectReqDTO = {
  properties: {
    name: {
      type: "string",
      description: "The name of the project",
    },
  },
  type: "object",
  required: ["name"],
} as const;

export const $ProjectDeleteReqDTO = {
  properties: {
    projectId: {
      format: "uuid",
      type: "string",
      description: "The ID of the project to delete",
    },
  },
  type: "object",
  required: ["projectId"],
} as const;

export const $ProjectResDTO = {
  properties: {
    id: {
      type: "string",
      description: "The ID or UUID of the project",
    },
    name: {
      type: "string",
      description: "The name of the project",
    },
    createdAt: {
      type: "string",
    },
    primaryApiKey: {
      type: "string",
    },
  },
  type: "object",
  required: ["id", "name", "createdAt", "primaryApiKey"],
  description: "The list of projects",
} as const;

export const $ProjectListResDTO = {
  properties: {
    items: {
      items: {
        $ref: "#/components/schemas/ProjectResDTO",
      },
      type: "array",
    },
  },
  type: "object",
  required: ["items"],
} as const;

export const $OrgApiKeyResDTO = {
  properties: {
    apiKey: {
      type: "string",
      description:
        "The api key for organisation operations. Can be passed in the header as 'X-Org-Api-Key'",
    },
  },
  type: "object",
  required: ["apiKey"],
} as const;

export const $OrgApiKeyRegenerateResDTO = {
  properties: {
    newApiKey: {
      type: "string",
      description:
        "Api key for organisation operations. Can be passed in the header as 'X-Org-Api-Key'",
    },
  },
  type: "object",
  required: ["newApiKey"],
} as const;

export const $InviteMemberReqDTO = {
  properties: {
    email: {
      format: "email",
      type: "string",
      description: "The email of the member",
    },
    name: {
      type: "string",
      description: "The name of the member",
    },
    verifyHost: {
      type: "string",
      description: "The host to verify the member",
    },
    role: {
      enum: ["admin", "developer"],
      type: "string",
      description: "The role that will be assignied to the invited user",
    },
  },
  type: "object",
  required: ["email", "name", "verifyHost"],
} as const;

export const $MemberResDTO = {
  properties: {
    email: {
      type: "string",
      description: "The email of the member",
    },
    id: {
      type: "string",
      description: "The uuid identifier for the member",
    },
    name: {
      type: "string",
      description: "The name of the member",
    },
    createdAt: {
      pattern: "\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d.\\d+Z?",
      type: "string",
      description: "The creation date of the member record",
    },
    role: {
      enum: ["admin", "developer"],
      type: "string",
      description: "The role that is assigned to the member",
    },
    updatedAt: {
      pattern: "\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d.\\d+Z?",
      type: "string",
      description: "The last update date of the member record",
    },
  },
  type: "object",
  required: ["email", "id", "name", "role"],
} as const;

export const $UpdateMemberReqDTO = {
  properties: {
    memberId: {
      type: "string",
      description: "The uuid identifier for the member",
    },
    role: {
      enum: ["admin", "developer"],
      type: "string",
      description: "The role that is assigned to the member",
    },
  },
  type: "object",
  required: ["memberId", "role"],
} as const;

export const $GenerateAPIKeyReqDTO = {
  properties: {
    name: {
      type: "string",
      description: "The name of the API key to be generated",
    },
  },
  type: "object",
  required: ["name"],
} as const;

export const $APIKeyResDTO = {
  properties: {
    id: {
      type: "string",
      description: "The ID of the API key",
    },
    name: {
      type: "string",
      description: "The name of the API key",
    },
    createdAt: {
      pattern: "\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d.\\d+Z?",
      type: "string",
      description: "The creation date of the API key",
    },
    updatedAt: {
      pattern: "\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d.\\d+Z?",
      type: "string",
      description: "The last update date of the API key",
    },
    key: {
      type: "string",
      description: "The generated API key",
    },
    isHidden: {
      type: "boolean",
      description: "Whether the API key is hidden",
    },
    lastUsed: {
      pattern: "\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d.\\d+Z?",
      type: "string",
      description: "The last used date of the API key",
    },
    member: {
      type: "object",
      description: "The member of the API key",
    },
  },
  type: "object",
  required: [
    "id",
    "name",
    "createdAt",
    "updatedAt",
    "key",
    "isHidden",
    "member",
  ],
} as const;

export const $DeleteAPIKeyReqDTO = {
  properties: {
    id: {
      type: "string",
      description: "The ID of the API key to be deleted",
    },
  },
  type: "object",
  required: ["id"],
} as const;

export const $DeleteAPIKeyResponseDTO = {
  properties: {
    deleted: {
      type: "boolean",
      description: "The status of the delete operation",
    },
  },
  type: "object",
  required: ["deleted"],
} as const;

export const $SingleAppInfoResDTO = {
  properties: {
    appId: {
      type: "string",
      description: "Unique identifier (UUID) for the app",
      example: "550e8400-e29b-41d4-a716-446655440000",
    },
    key: {
      type: "string",
      description:
        "Unique key/slug used to identify the app in URLs and API calls.",
      example: "salesforce-crm",
    },
    name: {
      type: "string",
      description: "Human-readable display name of the app",
      example: "Salesforce CRM",
    },
    description: {
      type: "string",
      description: "Short description about the app",
      example:
        "Enterprise CRM solution for managing customer relationships and sales pipelines",
    },
    logo: {
      type: "string",
      description: "URL to the app's logo image, used for UI display",
      example: "https://example.com/images/app-logo.png",
    },
    categories: {
      items: {
        type: "string",
      },
      type: "array",
      description: "The categories of the app",
    },
    docs: {
      type: "string",
      description:
        "The documentation URL of the app, if available. Usually it's a link to the doc to setup and configure the app.",
    },
    configuration_docs_text: {
      type: "string",
      description:
        "The configuration documentation text of the app. This is deprecated and not used anywhere.",
      deprecated: true,
    },
    status: {
      type: "string",
      description:
        "The status of the app. This is deprecated and not used anymore.",
      deprecated: true,
    },
    documentation_doc_text: {
      type: "string",
      description:
        "The documentation text of the app. This is deprecated and not used anywhere.",
      deprecated: true,
    },
    testConnectors: {
      items: {
        type: "object",
      },
      type: "array",
      description:
        "The test connectors available for the app. If this is not empty, it means composio allows you to setup this app without configuring and setting up your own auth app.",
    },
    no_auth: {
      type: "boolean",
      description:
        "Indicates if the app is of `no_auth` type. If this is true, you can directly use the app without creating any integration.",
    },
    auth_schemes: {
      items: {
        type: "object",
      },
      type: "array",
      description:
        "The authentication schemes supported by the app. This contains all the fields and details needed to setup and configure auth for this app.",
    },
    meta: {
      description: "The metadata of the app",
    },
  },
  type: "object",
  required: ["appId", "key", "name", "description"],
} as const;

export const $AddToolsReqDTO = {
  properties: {
    name: {
      type: "string",
      description:
        "The unique identifier name of the tool to be added. Must be URL-friendly and unique across the system",
      example: "my-custom-tool",
    },
    openApiSpecYaml: {
      type: "string",
      description:
        "The complete OpenAPI/Swagger specification in YAML format defining the tool's API endpoints, parameters, and responses",
      example: `openapi: 3.0.0
info:
  title: My API
  version: 1.0.0`,
    },
    integrationYaml: {
      type: "string",
      description:
        "YAML configuration specifying integration details including authentication, endpoints mapping, and other tool-specific settings",
      example: `auth:
  type: oauth2
endpoints:
  base_url: https://api.example.com`,
    },
  },
  type: "object",
  required: ["name", "openApiSpecYaml", "integrationYaml"],
} as const;

export const $OpenAPISpecListResDTO = {
  properties: {
    id: {
      type: "string",
      description: "Unique identifier (UUID) for the OpenAPI specification",
      example: "550e8400-e29b-41d4-a716-446655440000",
    },
    name: {
      type: "string",
      description:
        "Human-readable name of the OpenAPI specification. Used for display and reference purposes",
      example: "Payment Processing API",
    },
    clientId: {
      type: "string",
      description:
        "Unique identifier of the client who owns this OpenAPI specification",
      example: "client_12345",
    },
    lastSyncAt: {
      pattern: "\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d.\\d+Z?",
      type: "string",
      description:
        "ISO 8601 timestamp of when the specification was last synchronized with the source",
      format: "date-time",
      example: "2024-03-15T14:30:00Z",
    },
    createdAt: {
      pattern: "\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d.\\d+Z?",
      type: "string",
      description: "Creation date and time",
      format: "date-time",
    },
    updatedAt: {
      pattern: "\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d.\\d+Z?",
      type: "string",
      description: "Last update date and time",
      format: "date-time",
    },
    status: {
      enum: [
        "initialized",
        "running",
        "caching",
        "cancelled",
        "finished",
        "exited",
      ],
      type: "string",
      description:
        "Current processing status of the OpenAPI specification in the pipeline. Indicates success, failure, or processing state",
      example: "COMPLETED",
    },
    state: {
      enum: [
        "preprocess",
        "validate",
        "prepare",
        "build",
        "push",
        "load",
        "finish",
      ],
      type: "string",
      description: "Current state of the app FSM",
    },
  },
  type: "object",
  required: ["id", "name", "clientId", "lastSyncAt", "createdAt", "updatedAt"],
} as const;

export const $AddRepoURLResDTO = {
  properties: {
    repoUrl: {
      type: "string",
      description: "Repository URL",
    },
  },
  type: "object",
  required: ["repoUrl"],
} as const;

export const $DeleteToolsReqDTO = {
  properties: {
    name: {
      type: "string",
      description: "Name of the tool",
    },
  },
  type: "object",
  required: ["name"],
} as const;

export const $DeleteToolsResDTO = {
  properties: {
    message: {
      type: "string",
      description: "Message indicating successful deletion of tools",
    },
  },
  type: "object",
  required: ["message"],
} as const;

export const $AddToolsRequestDTO = {
  properties: {
    name: {
      type: "string",
      description: "The name of the tool",
    },
    open_api_spec_yaml: {
      type: "string",
      description: "The OpenAPI specification in YAML format",
    },
    integration_yaml: {
      type: "string",
      description: "The integration details in YAML format",
    },
  },
  type: "object",
  required: ["name", "open_api_spec_yaml", "integration_yaml"],
} as const;

export const $AddRepoURLReqDTO = {
  properties: {
    repoUrl: {
      type: "string",
      description: "Repository URL",
    },
  },
  type: "object",
  required: ["repoUrl"],
} as const;

export const $AppQueryDTO = {
  properties: {
    category: {
      type: "string",
      description: `Filter apps by category. Used to retrieve apps belonging to a specific group or type.
            To get a list of available categories, see the [Get App Categories](#operation/getAppCategories) endpoint.`,
      example: "crm",
    },
    additionalFields: {
      type: "string",
      description:
        "Comma-separated list of additional fields to include in the response. Allows customizing the response payload for app details. Supported fields: auth_schemes",
      example: "auth_schemes",
    },
    includeLocal: {
      enum: ["true", "false"],
      type: "string",
      description:
        "Filter to include locally developed/testing apps in the response. Must be 'true' or 'false'",
      example: "true",
      default: "false",
    },
    sortBy: {
      enum: ["alphabet", "usage", "no_sort"],
      type: "string",
      description: "Sort the apps by usage or alphabetically",
      example: "usage",
      default: "alphabetically",
    },
  },
  type: "object",
} as const;

export const $TestConnector = {
  properties: {
    id: {
      type: "string",
      description: "The id of the test connector",
    },
    name: {
      type: "string",
      description: "The name of the test connector",
    },
    authScheme: {
      enum: [
        "OAUTH2",
        "OAUTH1",
        "OAUTH1A",
        "API_KEY",
        "BASIC",
        "BEARER_TOKEN",
        "GOOGLE_SERVICE_ACCOUNT",
        "NO_AUTH",
        "BASIC_WITH_JWT",
        "COMPOSIO_LINK",
        "CALCOM_AUTH",
      ],
      type: "string",
      description: "The auth scheme of the test connector",
    },
  },
  type: "object",
  required: ["id", "name", "authScheme"],
} as const;

export const $AppInfoResponseDto = {
  properties: {
    appId: {
      type: "string",
      description: "Unique identifier (UUID) for the app",
      example: "550e8400-e29b-41d4-a716-446655440000",
    },
    key: {
      type: "string",
      description:
        "Unique key/slug for the app, used in URLs and API references",
      example: "salesforce-crm",
    },
    name: {
      type: "string",
      description: "The name of the app",
    },
    description: {
      type: "string",
      description: "The description of the app",
    },
    logo: {
      type: "string",
      description: "The logo of the app",
    },
    categories: {
      items: {
        type: "object",
      },
      type: "string",
      description: "The categories of the app",
    },
    tags: {
      items: {
        type: "object",
      },
      type: "string",
      description: "The tags of the app",
    },
    auth_schemes: {
      description: "The authentication schemes of the app",
    },
    testConnectors: {
      items: {
        type: "object",
      },
      type: "array",
      $ref: "#/components/schemas/TestConnector",
      description: "The authentication schemes of the app",
    },
    enabled: {
      type: "boolean",
      description: "Indicates if the app is enabled",
    },
    no_auth: {
      type: "boolean",
      description: "Indicates if the app has no authentication",
    },
    createdAt: {
      oneOf: [
        {
          format: "date",
          type: "string",
        },
        {
          format: "date-time",
          type: "string",
        },
      ],
      description: "The creation date of the app",
    },
    updatedAt: {
      oneOf: [
        {
          format: "date",
          type: "string",
        },
        {
          format: "date-time",
          type: "string",
        },
      ],
      description: "The last update date of the app",
    },
  },
  type: "object",
  required: [
    "appId",
    "key",
    "name",
    "description",
    "logo",
    "categories",
    "enabled",
    "createdAt",
    "updatedAt",
  ],
} as const;

export const $AppListCategoriesResDTO = {
  properties: {
    items: {
      items: {
        type: "string",
      },
      type: "array",
      description: "List of app categories",
    },
  },
  type: "object",
  required: ["items"],
} as const;

export const $AppListResDTO = {
  properties: {
    items: {
      items: {
        $ref: "#/components/schemas/AppInfoResponseDto",
      },
      type: "array",
      description: "List of app details",
    },
    totalPages: {
      type: "number",
      description: "Total number of pages",
    },
  },
  type: "object",
  required: ["items", "totalPages"],
} as const;

export const $ExpectedInputFieldsDTO = {
  properties: {
    name: {
      type: "string",
      description:
        "The unique identifier/key for this input field that will be used when submitting values. Must be URL-safe.",
    },
    type: {
      type: "string",
      description:
        "The data type of this field. Common types include 'string', 'number', 'boolean', etc.",
    },
    description: {
      type: "string",
      description:
        "Detailed explanation of what this field is used for and any special requirements or formatting needed.",
    },
    display_name: {
      type: "string",
      description:
        "Human-readable label that will be shown to users when they need to input this field.",
    },
    default: {
      type: "object",
      description:
        "Default value for this field if none is provided. Set to null if no default exists.",
    },
    required: {
      type: "boolean",
      description:
        "Indicates if this field must be provided for the connector to function properly.",
    },
    expected_from_customer: {
      type: "boolean",
      description:
        "Indicates if this field needs to be provided by the end user rather than being automatically populated.",
    },
    is_secret: {
      type: "boolean",
      description:
        "If true, this field contains sensitive information and should be handled securely (e.g. passwords, API keys).",
    },
  },
  type: "object",
  required: [
    "name",
    "type",
    "description",
    "display_name",
    "default",
    "required",
    "expected_from_customer",
    "is_secret",
  ],
} as const;

export const $GetConnectorInfoResDTO = {
  properties: {
    id: {
      type: "string",
      description:
        "Unique identifier for the connector. You can use this ID when calling endpoints like `POST /api/v1/connectedAccounts` to create connections.",
    },
    authScheme: {
      type: "string",
      description:
        "The authentication method used by this connector. Refer to the API documentation for supported authentication schemes.",
    },
    name: {
      type: "string",
      description: "The display name of this specific connector configuration.",
    },
    createdAt: {
      pattern: "\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d.\\d+Z?",
      type: "string",
      description: "ISO 8601 timestamp of when this connector was created.",
    },
    updatedAt: {
      pattern: "\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d.\\d+Z?",
      type: "string",
      description:
        "ISO 8601 timestamp of when this connector was last modified.",
    },
    enabled: {
      type: "boolean",
      description:
        "Whether this connector is currently active and can be used to create new connections. Can be toggled using the connector management endpoints.",
    },
    deleted: {
      type: "boolean",
      description:
        "Soft deletion status of the connector. If true, the connector has been marked for deletion but may still exist in the system.",
    },
    appId: {
      type: "string",
      description:
        "The ID of the application this connector belongs to. You can find available apps using the `GET /api/v1/apps` endpoint.",
    },
    defaultConnectorId: {
      type: "string",
      description:
        "If this is a custom connector, this field may reference the original template connector it was based on.",
    },
    authConfig: {
      type: "object",
      description:
        "Configuration object containing authentication settings. Sensitive values will be redacted. The structure varies based on the authScheme.",
    },
    expectedInputFields: {
      items: {
        $ref: "#/components/schemas/ExpectedInputFieldsDTO",
      },
      type: "array",
      description:
        "List of fields that need to be collected from users to set up a connection using this connector. These fields should be included when calling `POST /api/v1/connectedAccounts`.",
    },
    logo: {
      type: "string",
      description:
        "URL to the application's logo image that can be displayed in the UI.",
    },
    appName: {
      type: "string",
      description:
        "The name of the application this connector integrates with.",
    },
    useComposioAuth: {
      type: "boolean",
      description:
        "When true, indicates that this connector uses Composio's built-in authentication handling rather than custom authentication logic.",
    },
    limitedActions: {
      items: {
        type: "string",
      },
      type: "array",
      description: "Array of action strings that this connector is limited to.",
    },
  },
  type: "object",
  required: [
    "enabled",
    "appId",
    "authConfig",
    "expectedInputFields",
    "logo",
    "appName",
    "useComposioAuth",
    "limitedActions",
  ],
} as const;

export const $AuthConfigDTO = {
  properties: {
    scopes: {
      items: {
        type: "string",
      },
      type: "array",
      description:
        "List of OAuth scopes to request during the OAuth flow. These scopes determine what permissions the connector will have on the target service.",
    },
    user_scopes: {
      items: {
        type: "string",
      },
      type: "array",
      description:
        "List of user-specific OAuth scopes to request during the OAuth flow. Some APIs differentiate between app-level and user-level scopes.",
    },
  },
  type: "object",
  description: "Authentication configuration for the connector",
} as const;

export const $CreateConnectorPayloadDTO = {
  properties: {
    name: {
      type: "string",
      description:
        "A unique name for your connector. This will be used to identify the connector in the system.",
    },
    authScheme: {
      type: "string",
      description:
        "The authentication scheme used by the connector. Refer to the `/api/v1/apps` endpoint to see supported authentication schemes for each app.",
    },
    authConfig: {
      $ref: "#/components/schemas/AuthConfigDTO",
      description:
        "Configuration options for authentication. Required when using OAuth-based authentication schemes.",
    },
    useComposioAuth: {
      type: "boolean",
      description:
        "When set to true, the connector will use Composio's built-in authentication system. Learn more in the Authentication section of the API documentation.",
      anyOf: [
        {
          type: "boolean",
        },
      ],
    },
    appId: {
      type: "string",
      description:
        "UUID of the Composio app to use for authentication. You can get this from the `id` field in the response of the `GET /api/v1/apps` endpoint. Either specify this or appName.",
    },
    appName: {
      type: "string",
      description:
        "Name of the Composio app to use for authentication. You can get this from the `name` field in the response of the `GET /api/v1/apps` endpoint. Either specify this or appId.",
    },
    forceNewIntegration: {
      type: "boolean",
      description:
        "When set to true, creates a new integration even if one already exists for the given app. This is useful when you need multiple integrations with the same service.",
    },
    limitedActions: {
      items: {
        type: "string",
      },
      type: "array",
      description:
        "List of actions to limit the connector to. If not provided, all actions will be enabled.",
    },
  },
  type: "object",
  required: ["name"],
} as const;

export const $PatchConnectorReqDTO = {
  properties: {
    authConfig: {
      type: "object",
      description:
        "Authentication configuration for the connector. This object contains the necessary credentials and settings required to authenticate with the external service. You can get the required configuration fields from the `GET /api/v1/connectors/{connectorId}/config` endpoint.",
    },
    limitedActions: {
      items: {
        type: "string",
      },
      type: "array",
      description:
        "A list of actions that are limited or restricted for the connector. This can be used to specify which actions the connector is allowed or not allowed to perform. The list of possible actions can be found in the API documentation.",
    },
    enabled: {
      type: "boolean",
      description:
        "Flag to indicate if the connector is enabled. When set to false, the connector will not process any requests. You can toggle this value to temporarily disable the connector without deleting it. Default value can be found in the `GET /api/v1/connectors/{connectorId}` endpoint response.",
    },
  },
  type: "object",
} as const;

export const $PatchConnectorResDTO = {
  properties: {
    status: {
      type: "string",
      description:
        "Status of the patch operation. Returns 'success' when the connector is successfully updated. For detailed information about possible status values, refer to the API documentation at `PATCH /api/v1/connectors/{connectorId}`.",
    },
  },
  type: "object",
  required: ["status"],
} as const;

export const $ConnectorListItemDTO = {
  properties: {
    appName: {
      type: "string",
      description:
        "Name of the application associated with this connector. You can find this in the response of the `GET /api/v1/apps` endpoint.",
    },
    _count: {
      type: "object",
      description:
        "Aggregate count of connections associated with this connector. This helps track how many connected accounts are using this connector configuration.",
    },
    connections: {
      items: {
        type: "object",
      },
      type: "array",
      description:
        "List of connections associated with this connector, including their IDs and request log counts. Each connection represents a unique connected account using this connector configuration.",
    },
    id: {
      type: "string",
      description:
        "Unique identifier (UUID) of the connector. You can use this ID when calling endpoints like `GET /api/v1/connectors/{id}` or `PUT /api/v1/connectors/{id}`.",
    },
    member: {
      $ref: "#/components/schemas/MemberInfoResDTO",
    },
    name: {
      type: "string",
      description:
        "Display name of the connector. This name is used to identify the connector in the UI and API responses.",
    },
    authScheme: {
      type: "string",
      description:
        "Authentication scheme used by this connector. Determines how authentication is handled for connected accounts. See the Authentication Schemes section in the API documentation for more details.",
    },
    createdAt: {
      oneOf: [
        {
          format: "date",
          type: "string",
        },
        {
          format: "date-time",
          type: "string",
        },
      ],
      description:
        "Timestamp when this connector was created. Returned in ISO 8601 format.",
    },
    updatedAt: {
      oneOf: [
        {
          format: "date",
          type: "string",
        },
        {
          format: "date-time",
          type: "string",
        },
      ],
      description:
        "Timestamp when this connector was last updated. Returned in ISO 8601 format.",
    },
    enabled: {
      type: "boolean",
      description:
        "Indicates whether the connector is currently enabled. Disabled connectors cannot be used to create new connections.",
    },
    deleted: {
      type: "boolean",
      description:
        "Soft deletion flag for the connector. When true, the connector is marked as deleted but remains in the database. You can filter deleted connectors using the `includeDeleted` query parameter in list endpoints.",
    },
    appId: {
      type: "string",
      description:
        "Unique identifier (UUID) of the app this connector belongs to. You can use this ID to fetch app details via the `GET /api/v1/apps/{id}` endpoint.",
    },
    defaultConnectorId: {
      type: "string",
      description:
        "ID of the default connector configuration. When present, this indicates that this connector inherits settings from the specified default connector. You can manage default connectors via the `/api/v1/defaultConnectors` endpoints.",
    },
  },
  type: "object",
  required: [
    "appName",
    "_count",
    "connections",
    "id",
    "member",
    "name",
    "authScheme",
    "createdAt",
    "updatedAt",
    "enabled",
    "appId",
  ],
  description:
    "List of connectors with their details and associated connections",
} as const;

export const $GetConnectorListResDTO = {
  properties: {
    items: {
      items: {
        $ref: "#/components/schemas/ConnectorListItemDTO",
      },
      type: "array",
      description:
        "Array of connector items matching the query parameters. Each item contains detailed information about a connector and its associated connections.",
    },
    totalPages: {
      type: "number",
      description:
        "Total number of pages available based on the current page size. Use this for implementing pagination controls.",
    },
    page: {
      type: "number",
      description:
        "Current page number (1-based). You can request different pages using the `page` query parameter in the `GET /api/v1/connectors` endpoint.",
    },
  },
  type: "object",
  required: ["items", "totalPages", "page"],
} as const;

export const $PageInfo = {
  properties: {
    total: {
      minimum: 0,
      type: "integer",
    },
    page: {
      minimum: 1,
      type: "integer",
    },
    pageSize: {
      minimum: 1,
      type: "integer",
    },
    totalPages: {
      minimum: 1,
      type: "integer",
    },
  },
  type: "object",
  required: ["total", "page", "pageSize", "totalPages"],
} as const;

export const $ConnectionWithAppData = {
  properties: {
    id: {
      type: "string",
    },
    integrationId: {
      type: "string",
    },
    clientUniqueUserId: {
      type: "string",
    },
    status: {
      type: "string",
    },
    data: {
      type: "object",
    },
    deleted: {
      type: "boolean",
    },
    enabled: {
      type: "boolean",
    },
    createdAt: {
      oneOf: [
        {
          format: "date",
          type: "string",
        },
        {
          format: "date-time",
          type: "string",
        },
      ],
    },
    updatedAt: {
      oneOf: [
        {
          format: "date",
          type: "string",
        },
        {
          format: "date-time",
          type: "string",
        },
      ],
    },
    appUniqueId: {
      type: "string",
    },
    appName: {
      type: "string",
    },
    logo: {
      type: "string",
    },
    authConfig: {
      type: "object",
    },
    member: {
      items: {
        $ref: "#/components/schemas/MemberInfoResDTO",
      },
      type: "object",
    },
    labels: {
      items: {
        type: "string",
      },
      type: "array",
    },
  },
  type: "object",
  required: [
    "id",
    "integrationId",
    "status",
    "createdAt",
    "updatedAt",
    "appUniqueId",
    "appName",
    "member",
  ],
} as const;

export const $GetConnectionsResult = {
  properties: {
    connections: {
      items: {
        $ref: "#/components/schemas/ConnectionWithAppData",
      },
      type: "array",
    },
    pageInfo: {
      $ref: "#/components/schemas/PageInfo",
    },
  },
  type: "object",
  required: ["connections", "pageInfo"],
} as const;

export const $GetConnectionInfoParams = {
  properties: {
    connectedAccountId: {
      minLength: 1,
      type: "string",
      description:
        "UUID of the connected account you want to get auth credentials for. You can get this from the `id` field in the response of the [/api/v1/connectedAccounts](/api-reference/connections/list-connections) endpoint.",
    },
  },
  type: "object",
  required: ["connectedAccountId"],
} as const;

export const $ConnectionParams = {
  properties: {
    integrationId: {
      type: "string",
      description:
        "The ID of the integration this connection belongs to. You can get this from the [/api/v1/integrations](/api-reference/integrations/list-integrations) endpoint.",
    },
    connectionParams: {
      type: "object",
      description:
        "Additional parameters specific to this connection. Structure varies by integration type.",
    },
    isDisabled: {
      type: "boolean",
      description: "Flag indicating if this connection is currently disabled.",
    },
    invocationCount: {
      type: "number",
      description: "Number of times this connection has been invoked/used.",
    },
    id: {
      type: "string",
    },
    clientUniqueUserId: {
      type: "string",
    },
    status: {
      type: "string",
    },
    data: {
      type: "object",
    },
    deleted: {
      type: "boolean",
    },
    enabled: {
      type: "boolean",
    },
    createdAt: {
      oneOf: [
        {
          format: "date",
          type: "string",
        },
        {
          format: "date-time",
          type: "string",
        },
      ],
    },
    updatedAt: {
      oneOf: [
        {
          format: "date",
          type: "string",
        },
        {
          format: "date-time",
          type: "string",
        },
      ],
    },
    appUniqueId: {
      type: "string",
    },
    appName: {
      type: "string",
    },
    logo: {
      type: "string",
    },
    authConfig: {
      type: "object",
    },
    member: {
      items: {
        $ref: "#/components/schemas/MemberInfoResDTO",
      },
      type: "object",
    },
    labels: {
      items: {
        type: "string",
      },
      type: "array",
    },
  },
  type: "object",
  required: [
    "integrationId",
    "isDisabled",
    "invocationCount",
    "id",
    "status",
    "createdAt",
    "updatedAt",
    "appUniqueId",
    "appName",
    "member",
  ],
} as const;

export const $ToggleConnectedAccountResponseDTO = {
  properties: {
    status: {
      type: "string",
      description:
        "The status of the toggle operation ('success' or 'failed').",
    },
  },
  type: "object",
  required: ["status"],
} as const;

export const $ConnectionParamsHeaders = {
  properties: {
    Authorization: {
      type: "string",
      description: "Authorization header value used for API requests.",
    },
    "x-request-id": {
      type: "string",
      description: "Request ID header for tracing API calls.",
    },
  },
  type: "object",
  description: "Headers to be included in API requests.",
} as const;

export const $ConnectionParamsForAccount = {
  properties: {
    scope: {
      type: "string",
      description: "OAuth scope for the connection.",
    },
    scopes: {
      type: "string",
      description: "Space-separated OAuth scopes for the connection.",
    },
    id_token: {
      type: "string",
      description: "OAuth ID token for authentication.",
    },
    client_id: {
      type: "string",
      description: "OAuth client ID for the application.",
    },
    expires_in: {
      type: "string",
      description: "Token expiration time in seconds.",
    },
    token_type: {
      type: "string",
      description: "Type of OAuth token (e.g. 'Bearer').",
    },
    callback_url: {
      type: "string",
      description: "OAuth callback URL for the connection.",
    },
    client_secret: {
      type: "string",
      description: "OAuth client secret for the application.",
    },
    code_verifier: {
      type: "string",
      description: "PKCE code verifier used in OAuth flow.",
    },
    refresh_token: {
      type: "string",
      description: "OAuth refresh token for obtaining new access tokens.",
    },
    headers: {
      type: "object",
    },
    queryParams: {
      type: "object",
      description: "Query parameters to be included in API requests.",
    },
    base_url: {
      type: "string",
      description: "Base URL for API requests to the connected service.",
    },
  },
  type: "object",
} as const;

export const $MetaApp = {
  properties: {
    get_current_user_endpoint: {
      type: "string",
      description:
        "Endpoint URL to fetch current user information from the connected service.",
    },
  },
  type: "object",
  required: ["get_current_user_endpoint"],
  description: "Additional information related to the app.",
} as const;

export const $Meta = {
  properties: {
    app: {
      type: "object",
      description: "App-specific metadata.",
    },
  },
  type: "object",
  required: ["app"],
  description: "Additional information related to the connected account.",
} as const;

export const $ConnectedAccountResponseDTO = {
  properties: {
    integrationId: {
      format: "uuid",
      type: "string",
      description:
        "The ID of the integration to which the connected account belongs. You can get this from the [/api/v1/integrations](/api-reference/integrations/list-integrations) endpoint.",
    },
    appUniqueId: {
      type: "string",
      description:
        "The unique ID of the app to which the connected account belongs. To get the full app info, you can use the [/api/v1/apps](/api-reference/apps/get-single-app) endpoint.",
    },
    memberInfo: {
      $ref: "#/components/schemas/MemberInfoResDTO",
    },
    meta: {
      $ref: "#/components/schemas/Meta",
    },
    isDisabled: {
      type: "boolean",
      description:
        "Flag to indicate if the connected account is disabled. If this is true, the connected account will not be able to be used for any actions.",
    },
    id: {
      format: "uuid",
      type: "string",
      description: "The unique identifier for this connected account.",
    },
    clientUniqueUserId: {
      type: "string",
      description:
        "The entityId to which the connected account belongs. **Deprecated: ** Please use the `entityId` field instead.",
      deprecated: true,
    },
    appName: {
      type: "string",
      description:
        "The name of the app this account is connected to. You can get the list of available apps from the [/api/v1/apps](/api-reference/apps/list-apps) endpoint.",
    },
    entityId: {
      type: "string",
      description:
        "The entity ID associated with the connection. Learn more about entities [here](https://docs.composio.dev/patterns/Auth/connected_account#entities).",
    },
    status: {
      enum: ["INITIATED", "ACTIVE", "FAILED", "EXPIRED"],
      type: "string",
      description:
        "The current status of the connection (e.g. 'active', 'inactive', 'pending').",
    },
    enabled: {
      type: "boolean",
      description:
        "Flag to indicate if the connected account is enabled. This will be true if the connected account is active and can be used to perform actions.",
    },
    createdAt: {
      type: "string",
      description: "The date and time when the connected account was created.",
    },
    updatedAt: {
      type: "string",
      description:
        "The date and time when the connected account was last updated.",
    },
  },
  type: "object",
  required: [
    "integrationId",
    "appUniqueId",
    "id",
    "clientUniqueUserId",
    "appName",
    "entityId",
    "status",
    "createdAt",
    "updatedAt",
  ],
} as const;

export const $GetConnectionsResponseDto = {
  properties: {
    items: {
      items: {
        $ref: "#/components/schemas/ConnectionParams",
      },
      type: "array",
      description: "Array of connection objects matching the query parameters.",
    },
    totalPages: {
      type: "number",
      description: "Total number of pages available based on the pageSize.",
    },
    page: {
      type: "number",
      description: "Current page number in the pagination.",
    },
  },
  type: "object",
  required: ["items", "totalPages", "page"],
} as const;

export const $GetConnectionInfoResponseDTO = {
  properties: {
    base_url: {
      type: "string",
      description:
        "The base URL of the connection. This is the starting part (or base part) of the URL that you need to send requests to. This is especially useful when you are working with apps that have dynamic urls (based on connection params) like Shopify.",
    },
    parameters: {
      items: {
        $ref: "#/components/schemas/Parameter",
      },
      type: "array",
    },
    body: {
      type: "object",
      description:
        "The body params to send with the request. Some apps require this to be sent in the body of the request for authentication.",
    },
  },
  type: "object",
  required: ["base_url", "parameters", "body"],
} as const;

export const $Parameter = {
  properties: {
    name: {
      type: "string",
      description:
        "The name of the parameter. For example, 'x-api-key', 'Content-Type', etc.",
    },
    in: {
      enum: ["query", "header"],
      type: "string",
      description: "The location of the parameter. Can be 'query' or 'header'.",
    },
    value: {
      type: "string",
      description:
        "The value of the parameter. For example, '1234567890', 'application/json', etc.",
    },
  },
  type: "object",
  required: ["name", "in", "value"],
  description:
    "The parameters to send with the request. This contains all the headers, query params, etc. that are required to make requests to the third-party service directly.",
} as const;

export const $Data = {
  properties: {
    field1: {
      type: "string",
      description: "First field of the data object.",
    },
    field2: {
      type: "string",
      description: "Second field of the data object.",
    },
  },
  type: "object",
  required: ["field1", "field2"],
} as const;

export const $AdditionalInfo = {
  properties: {
    meta: {
      type: "string",
      description: "Metadata information.",
    },
  },
  type: "object",
  required: ["meta"],
} as const;

export const $GetConnectionsQueryDto = {
  properties: {
    page: {
      minimum: 1,
      type: "number",
      description:
        "The page number for pagination. Defaults to 1 if not specified.",
    },
    pageSize: {
      minimum: 1,
      type: "number",
      description:
        "The number of items per page for pagination. Defaults to 99999999 if not specified - this is a temporary fix to support backward compatibility issues. Please specify this value to avoid fetching all connections at once.",
    },
    appNames: {
      type: "string",
      description:
        "Comma-separated list of app names to filter connections by. You can get the app names from the [/api/v1/apps](/api-reference/apps/list-apps) endpoint.",
    },
    labels: {
      type: "string",
      description: "Comma-separated list of labels to filter connections by.",
    },
    showActiveOnly: {
      type: "boolean",
      description:
        "Flag to show only active connections. Defaults to false if not specified.",
    },
    status: {
      type: "string",
      description:
        "Comma-separated list of connection statuses to filter by. The statuses are 'ACTIVE', 'EXPIRED', 'FAILED', 'INITIATED'.",
    },
    integrationId: {
      format: "uuid",
      type: "string",
      description:
        "The ID/UUID of the integration to filter connections by. You can get the integration ID from the [/api/v1/integrations](/api-reference/integrations/list-integrations) endpoint.",
    },
    connectionId: {
      format: "uuid",
      type: "string",
      description:
        "UUID of the connected account you want to get auth credentials for. You can get this from the `id` field in the response of the [/api/v1/connectedAccounts](/api-reference/connections/list-connections) endpoint.",
    },
    user_uuid: {
      type: "string",
      description:
        "Comma-separated list of entity IDs to filter connections by. This field is deprecated - please use entityId instead.",
      deprecated: true,
    },
    entityId: {
      type: "string",
      description:
        "Comma-separated list of entity ids of the user to filter connections by. Learn more about entities [here](https://docs.composio.dev/patterns/Auth/connected_account#entities).",
    },
    showDisabled: {
      type: "boolean",
      description:
        "Flag to include disabled connections in the results. Defaults to false if not specified.",
    },
  },
  type: "object",
} as const;

export const $GetSingleConnectionRequestDTO = {
  properties: {
    connectedAccountId: {
      minLength: 1,
      type: "string",
      description:
        "The ID of the connected account to get details for. You can get this from the `id` field in the response of the [/api/v1/connectedAccounts](/api-reference/connections/list-connections) endpoint.",
    },
  },
  type: "object",
  required: ["connectedAccountId"],
} as const;

export const $GetConnectionsHeaderParamsDTO = {
  properties: {
    "x-project-id": {
      format: "uuid",
      type: "string",
      description:
        "The ID of the project to get the connections for. Defaults to the first project in the list of projects. You can get the project ID from the [/api/v1/projects](/api-reference/client/get-projects) endpoint.",
    },
  },
  type: "object",
} as const;

export const $InitiateConnectionPayloadDto = {
  properties: {
    data: {
      type: "object",
      description:
        "The data required to initiate a connection. Structure varies by integration type.",
    },
    integrationId: {
      minLength: 1,
      type: "string",
      description:
        "The ID of the integration for which the connection is being initiated. You can get this from the [/api/v1/integrations](/api-reference/integrations/list-integrations) endpoint.",
    },
    redirectUri: {
      type: "string",
      description:
        "The URL to redirect to after the connection is successfully initiated.",
    },
    userUuid: {
      type: "string",
      description: "Deprecated: UUID of the user initiating the connection.",
    },
    entityId: {
      type: "string",
      description:
        "The entity ID to associate with the connection. Learn more about entities [here](https://docs.composio.dev/patterns/Auth/connected_account#entities).",
    },
    labels: {
      items: {
        type: "string",
      },
      type: "array",
      description:
        "Array of labels to associate with the connection for organization and filtering.",
    },
  },
  type: "object",
  required: ["data", "integrationId"],
} as const;

export const $ReinitiateConnectionPayloadDto = {
  properties: {
    data: {
      type: "object",
      description:
        "The data required to initiate a connection. Structure varies by integration type.",
    },
    redirectUri: {
      type: "string",
      description:
        "The URL to redirect to after the connection is successfully initiated.",
    },
  },
  type: "object",
  required: ["data"],
} as const;

export const $UpdateConnectionLabelsPayloadDto = {
  properties: {
    labels: {
      items: {
        type: "string",
      },
      type: "array",
      description: "Array of new labels to assign to the connection.",
    },
  },
  type: "object",
  required: ["labels"],
} as const;

export const $InitiateConnectionResponse = {
  properties: {
    connectionStatus: {
      minLength: 1,
      type: "string",
      description: "The current status of the initiated connection.",
    },
    connectedAccountId: {
      minLength: 1,
      type: "string",
      description: "The ID of the newly created connected account.",
    },
    redirectUrl: {
      type: "string",
      description:
        "URL to redirect to for completing the connection process, if required.",
    },
  },
  type: "object",
  required: ["connectionStatus", "connectedAccountId"],
} as const;

export const $ConnectedAccountNotFoundError = {
  properties: {
    name: {
      enum: ["ConnectedAccountNotFoundError"],
      type: "string",
      description: "The name of the error",
      example: "ConnectedAccountNotFoundError",
    },
    status: {
      minLength: 1,
      type: "number",
      description: "HTTP status code",
    },
    message: {
      minLength: 1,
      type: "string",
      description: "Error message",
    },
    requestId: {
      type: "string",
      description:
        "Request ID, used for tracing the request. This is very helpful for internal teams to debug issues.",
    },
    type: {
      minLength: 1,
      type: "string",
      enum: ["NotFoundError"],
      description: "The name of the operation that caused the error",
    },
  },
  type: "object",
  required: ["name", "status", "message", "requestId", "type"],
} as const;

export const $ListTriggersQueryDTO = {
  properties: {
    appNames: {
      type: "string",
      description:
        "Comma-separated list of app names to filter connections by. You can get the app names from the `name` field in the response of the `GET /api/v1/apps` endpoint.",
    },
    connectedAccountIds: {
      type: "string",
      description:
        "Comma-separated list of connected account IDs to filter triggers by. Returns all the possible triggers you can setup for these connected accounts. You can get the connected account IDs from the `id` field in the response of the `GET /api/v1/connections` endpoint.",
    },
    triggerIds: {
      type: "string",
      description:
        "(Deprecated) Please use `triggerNames` instead. Comma-separated list of trigger names to filter triggers by. You can get the trigger names from the `name` field in the response of the `GET /api/v1/triggers` endpoint.",
      deprecated: true,
    },
    triggerNames: {
      type: "string",
      description:
        "Comma-separated list of trigger names to filter triggers by. You can get the trigger names from the `name` field in the response of the `GET /api/v1/triggers` endpoint.",
    },
    integrationIds: {
      type: "string",
      description:
        "Comma-separated list of integration IDs to filter triggers by. You can get the integration IDs from the `id` field in the response of the `GET /api/v1/integrations` endpoint.",
    },
    showEnabledOnly: {
      type: "boolean",
      description:
        "When set to true, returns only enabled triggers. This field is deprecated and will be removed in future versions.",
      deprecated: true,
    },
  },
  type: "object",
} as const;

export const $GetActiveTriggersQueryDTO = {
  properties: {
    connectedAccountIds: {
      type: "string",
      description:
        "Comma-separated list of connected account IDs to filter triggers by. You can get these IDs from the `id` field in the response of the `GET /api/v1/connections` endpoint.",
    },
    integrationIds: {
      type: "string",
      description:
        "Comma-separated list of integration IDs to filter triggers by. You can get these IDs from the `id` field in the response of the `GET /api/v1/integrations` endpoint.",
    },
    triggerIds: {
      type: "string",
      description:
        "Comma-separated list of trigger IDs to filter triggers by. You can get these IDs from the `id` field in the response of the `GET /api/v1/triggers` endpoint.",
    },
    triggerNames: {
      type: "string",
      description:
        "Comma-separated list of trigger names to filter triggers by. You can get these names from the `name` field in the response of the `GET /api/v1/triggers` endpoint.",
    },
    page: {
      type: "number",
      description: "Page number for pagination. Starts from 1.",
    },
    limit: {
      type: "number",
      description: "Number of items to return per page.",
    },
    showDisabled: {
      type: "boolean",
      description:
        "When set to true, includes disabled triggers in the response.",
    },
  },
  type: "object",
} as const;

export const $GetLogsQueryDTO = {
  properties: {
    connectionId: {
      type: "string",
      description:
        "Filter logs by connection ID. You can get this from the `id` field in the response of the `GET /api/v1/connections` endpoint.",
    },
    integrationId: {
      type: "string",
      description:
        "Filter logs by integration ID. You can get this from the `id` field in the response of the `GET /api/v1/integrations` endpoint.",
    },
    page: {
      type: "number",
      description: "Page number for pagination. Starts from 1.",
    },
    limit: {
      type: "number",
      description: "Number of items to return per page.",
    },
  },
  type: "object",
} as const;

export const $TriggerResDTO = {
  properties: {
    name: {
      type: "string",
      description:
        "Unique identifier of the trigger. This is used to reference the trigger in other API calls.",
    },
    display_name: {
      type: "string",
      description: "Human-readable name of the trigger shown in the UI.",
    },
    description: {
      type: "string",
      description: "Detailed description of what the trigger does.",
    },
    enabled: {
      type: "boolean",
      description: "Indicates whether the trigger is currently enabled.",
    },
    config: {
      type: "object",
      description:
        "Configuration parameters required for the trigger. Structure varies based on trigger type.",
    },
    payload: {
      type: "object",
      description: "Sample payload that will be sent when the trigger fires.",
    },
    logo: {
      type: "string",
      description: "URL of the trigger's icon or logo.",
    },
    count: {
      type: "number",
      description: "Number of times this trigger has been activated.",
    },
    appKey: {
      type: "string",
      description: "Unique key identifying the app this trigger belongs to.",
    },
    appId: {
      type: "string",
      description:
        "Unique identifier of the app this trigger belongs to. You can get this from the `id` field in the response of the `GET /api/v1/apps` endpoint.",
    },
    appName: {
      type: "string",
      description: "Name of the app this trigger belongs to.",
    },
    instructions: {
      type: "string",
      description:
        "Step-by-step instructions on how to set up and use this trigger.",
    },
    type: {
      type: "string",
      description: "Classification or category of the trigger.",
    },
  },
  type: "object",
  required: ["name", "display_name", "appKey", "appId", "appName"],
} as const;

export const $SingleTriggerResDTO = {
  properties: {
    name: {
      type: "string",
      description:
        "Unique identifier of the trigger. Used to reference the trigger in other API calls.",
    },
    displayName: {
      type: "string",
      description: "Human-readable name of the trigger shown in the UI.",
    },
    description: {
      type: "string",
      description:
        "Detailed description of what the trigger does and when it fires.",
    },
    type: {
      type: "string",
      description: "Classification or category of the trigger.",
    },
    appId: {
      type: "string",
      description:
        "Unique identifier of the app this trigger belongs to. You can get this from the `id` field in the response of the `GET /api/v1/apps` endpoint.",
    },
    appName: {
      type: "string",
      description: "Name of the app this trigger belongs to.",
    },
    instructions: {
      type: "string",
      description:
        "Step-by-step instructions on how to set up and use this trigger.",
    },
    payload: {
      type: "object",
      description: "Sample payload that will be sent when the trigger fires.",
    },
    config: {
      type: "object",
      description:
        "Configuration parameters required for the trigger. Structure varies based on trigger type.",
    },
  },
  type: "object",
  required: [
    "name",
    "displayName",
    "description",
    "type",
    "appId",
    "appName",
    "payload",
    "config",
  ],
} as const;

export const $TriggerConfig = {
  properties: {
    repo: {
      type: "string",
      description: "Name of the repository to monitor.",
    },
    owner: {
      type: "string",
      description: "Owner (user or organization) of the repository.",
    },
  },
  type: "object",
  required: ["repo", "owner"],
  description: "Configuration parameters for a trigger",
} as const;

export const $ActiveTriggerInstance = {
  properties: {
    id: {
      type: "string",
      description: "Unique identifier of the trigger instance.",
    },
    connectionId: {
      type: "string",
      description:
        "ID of the connected account this trigger is associated with. You can get this from the `id` field in the response of the `GET /api/v1/connections` endpoint.",
    },
    triggerName: {
      type: "string",
      description:
        "Name of the trigger. You can get this from the `name` field in the response of the `GET /api/v1/triggers` endpoint.",
    },
    triggerData: {
      type: "string",
      description: "Additional data associated with the trigger instance.",
    },
    triggerConfig: {
      $ref: "#/components/schemas/TriggerConfig",
    },
    createdAt: {
      type: "string",
      description: "ISO 8601 timestamp when the trigger instance was created.",
      format: "date-time",
    },
    updatedAt: {
      type: "string",
      description:
        "ISO 8601 timestamp when the trigger instance was last updated.",
      format: "date-time",
    },
    disabledAt: {
      type: "string",
      description:
        "ISO 8601 timestamp when the trigger instance was disabled, if applicable.",
      format: "date-time",
      nullable: true,
    },
  },
  type: "object",
  required: [
    "connectionId",
    "triggerName",
    "triggerConfig",
    "createdAt",
    "updatedAt",
  ],
} as const;

export const $PageInfoDTO = {
  properties: {
    currentPage: {
      type: "number",
      description: "Current page number.",
    },
    perPage: {
      type: "number",
      description: "Number of items per page.",
    },
    totalPages: {
      type: "number",
      description: "Total number of pages available.",
    },
  },
  type: "object",
  required: ["currentPage", "perPage", "totalPages"],
} as const;

export const $ActiveTriggersResDTO = {
  properties: {
    triggers: {
      items: {
        $ref: "#/components/schemas/ActiveTriggerInstance",
      },
      type: "array",
      description: "List of active trigger instances.",
    },
    pageInfo: {
      items: {
        $ref: "#/components/schemas/PageInfoDTO",
      },
      type: "array",
      description: "Pagination information for the response.",
    },
  },
  type: "object",
  required: ["triggers", "pageInfo"],
} as const;

export const $TriggerLogsResDTO = {
  properties: {
    data: {
      items: {
        $ref: "#/components/schemas/TriggerLogItemDTO",
      },
      type: "array",
      description: "List of trigger log entries.",
    },
    pageInfo: {
      $ref: "#/components/schemas/PageInfoDTO",
      description: "Pagination information for the response.",
    },
  },
  type: "object",
  required: ["data", "pageInfo"],
} as const;

export const $TriggerLogItemDTO = {
  properties: {
    clientId: {
      type: "string",
      description:
        "Unique identifier of the client that initiated the trigger.",
    },
    connectionId: {
      type: "string",
      description:
        "ID of the connection associated with this log entry. You can get this from the `id` field in the response of the `GET /api/v1/connections` endpoint.",
    },
    triggerType: {
      enum: ["poll", "webhook"],
      type: "string",
      description: "Type of the trigger.",
    },
    errorTrigger: {
      type: "string",
      description: "Error message if the trigger failed.",
      nullable: true,
    },
    triggerClientError: {
      type: "string",
      description: "Client-side error message if any occurred.",
      nullable: true,
    },
    triggerClientPayload: {
      type: "string",
      description: "Payload sent by the client when the trigger was activated.",
      nullable: true,
    },
    triggerClientResponse: {
      type: "object",
      description: "Payload sent by the client when the trigger was activated.",
      nullable: true,
    },
    triggerProviderPayload: {
      type: "string",
      description: "Payload received from the provider's API.",
      nullable: true,
    },
    triggerName: {
      type: "string",
      description: "Name of the trigger that generated this log entry.",
      nullable: true,
    },
    id: {
      type: "string",
      description: "Unique identifier for this log entry.",
    },
    appKey: {
      type: "string",
      description: "Key identifying the app associated with this log entry.",
    },
    createdAt: {
      type: "string",
      description: "ISO 8601 timestamp when this log entry was created.",
      format: "date-time",
    },
  },
  type: "object",
  required: ["clientId", "connectionId", "id", "appKey", "createdAt"],
} as const;

export const $HandleTriggerParamsDTO = {
  properties: {
    appName: {
      type: "string",
      description:
        "Name of the app handling the trigger. You can get this from the `name` field in the response of the `GET /api/v1/apps` endpoint.",
    },
    clientId: {
      type: "string",
      description: "Unique identifier of the client initiating the trigger.",
    },
  },
  type: "object",
  required: ["appName", "clientId"],
} as const;

export const $HandleTriggerBodyDTO = {
  properties: {
    body: {
      type: "object",
      description: "Payload data to be processed by the trigger.",
    },
  },
  type: "object",
  required: ["body"],
} as const;

export const $EnableTriggerParamsDTO = {
  properties: {
    connectedAccountId: {
      type: "string",
      description:
        "ID of the connected account to enable the trigger for. You can get this from the `id` field in the response of the `GET /api/v1/connections` endpoint.",
    },
    triggerName: {
      type: "string",
      description:
        "Name of the trigger to enable. You can get this from the `name` field in the response of the `GET /api/v1/triggers` endpoint.",
    },
  },
  type: "object",
  required: ["connectedAccountId", "triggerName"],
} as const;

export const $GetTriggerParamsDTO = {
  properties: {
    triggerId: {
      type: "string",
      description:
        "Unique identifier of the trigger to retrieve. You can get this from the `id` field in the response of the `GET /api/v1/triggers` endpoint.",
    },
  },
  type: "object",
  required: ["triggerId"],
} as const;

export const $EnableTriggerBodyDTO = {
  properties: {
    triggerConfig: {
      type: "object",
      description:
        "Configuration parameters for the trigger. Structure varies based on trigger type.",
    },
    verifyHost: {
      type: "string",
      description: "Host URL for webhook verification, if required.",
    },
  },
  type: "object",
  required: ["triggerConfig"],
} as const;

export const $SwitchTriggerStatusParamsDTO = {
  properties: {
    triggerId: {
      type: "string",
      description:
        "Unique identifier of the trigger instance to update. You can get this from the `id` field in the response of the `GET /api/v1/triggers/active` endpoint.",
    },
  },
  type: "object",
  required: ["triggerId"],
} as const;

export const $SwitchTriggerStatusBodyDTO = {
  properties: {
    enabled: {
      type: "boolean",
      description: "New enabled/disabled state for the trigger.",
    },
  },
  type: "object",
  required: ["enabled"],
} as const;

export const $TriggerInstanceParamsDTO = {
  properties: {
    triggerInstanceId: {
      type: "string",
      description:
        "Unique identifier of the trigger instance to modify. You can get this from the `id` field in the response of the `GET /api/v1/triggers/active` endpoint.",
    },
  },
  type: "object",
  required: ["triggerInstanceId"],
} as const;

export const $SetCallbackUrlBodyDTO = {
  properties: {
    callbackURL: {
      type: "string",
      description:
        "URL where webhook notifications should be sent when the trigger fires.",
    },
  },
  type: "object",
  required: ["callbackURL"],
} as const;

export const $TriggerResponseDTO = {
  properties: {
    status: {
      type: "string",
      description: "Status of the operation (success/error).",
    },
    message: {
      type: "string",
      description: "Additional information about the operation result.",
    },
    triggerId: {
      type: "string",
      description: "Unique identifier of the affected trigger.",
    },
    isNew: {
      type: "boolean",
      description:
        "Indicates whether a new trigger was created (true) or an existing one was modified (false).",
    },
  },
  type: "object",
  required: ["status"],
} as const;

export const $WebhookURLResponseDTO = {
  properties: {
    status: {
      type: "string",
      description: "Status of the operation (success/error).",
    },
    callbackURL: {
      type: "string",
      description: "The currently configured webhook callback URL.",
    },
  },
  type: "object",
  required: ["status"],
} as const;

export const $TriggerMetadataDTO = {
  properties: {
    id: {
      type: "string",
      description: "Unique identifier of the trigger.",
    },
    connectionId: {
      type: "string",
      description:
        "ID of the connection this trigger is associated with. You can get this from the `id` field in the response of the `GET /api/v1/connections` endpoint.",
    },
    triggerName: {
      type: "string",
      description:
        "Name of the trigger. You can get this from the `name` field in the response of the `GET /api/v1/triggers` endpoint.",
    },
    triggerData: {
      type: "string",
      description: "Additional data associated with the trigger.",
    },
    triggerConfig: {
      type: "object",
      description:
        "Configuration parameters for the trigger. Structure varies based on trigger type.",
    },
    state: {
      type: "object",
      description: "Current state of the trigger.",
    },
    createdAt: {
      type: "string",
      description: "ISO 8601 timestamp when the trigger was created.",
      format: "date-time",
    },
    updatedAt: {
      type: "string",
      description: "ISO 8601 timestamp when the trigger was last updated.",
      format: "date-time",
    },
    disabledAt: {
      type: "string",
      description:
        "ISO 8601 timestamp when the trigger was disabled, if applicable.",
      format: "date-time",
      nullable: true,
    },
    disabledReason: {
      type: "string",
      description: "Reason why the trigger was disabled, if applicable.",
      nullable: true,
    },
  },
  type: "object",
  required: [
    "id",
    "connectionId",
    "triggerName",
    "triggerData",
    "triggerConfig",
    "state",
    "createdAt",
    "updatedAt",
  ],
  description: "Detailed information about a trigger",
} as const;

export const $GetTriggerResponseDTO = {
  properties: {
    status: {
      type: "string",
      description: "Status of the operation (success/error).",
    },
    trigger: {
      $ref: "#/components/schemas/TriggerMetadataDTO",
    },
  },
  type: "object",
  required: ["status"],
} as const;

export const $WehbookNewFormatDTO = {
  properties: {
    id: {
      type: "string",
      description: "Unique identifier of the project.",
    },
    isNewWebhook: {
      type: "boolean",
      description: "Indicates whether this is a newly created webhook.",
    },
  },
  type: "object",
  required: ["id", "isNewWebhook"],
} as const;

export const $TriggerNotFoundError = {
  properties: {
    name: {
      enum: ["TriggerNotFoundError"],
      type: "string",
      description: "The name of the error",
      example: "TriggerNotFoundError",
    },
    status: {
      minLength: 1,
      type: "number",
      description: "HTTP status code",
    },
    message: {
      minLength: 1,
      type: "string",
      description: "Error message",
    },
    requestId: {
      type: "string",
      description:
        "Request ID, used for tracing the request. This is very helpful for internal teams to debug issues.",
    },
    type: {
      minLength: 1,
      type: "string",
      enum: ["NotFoundError"],
      description: "The name of the operation that caused the error",
    },
  },
  type: "object",
  required: ["name", "status", "message", "requestId", "type"],
} as const;

export const $InvalidTriggerConfigError = {
  properties: {
    name: {
      enum: ["InvalidTriggerConfigError"],
      type: "string",
      description: "The name of the error",
      example: "InvalidTriggerConfigError",
    },
    status: {
      minLength: 1,
      type: "number",
      description: "HTTP status code",
    },
    message: {
      minLength: 1,
      type: "string",
      description: "Error message",
    },
    requestId: {
      type: "string",
      description:
        "Request ID, used for tracing the request. This is very helpful for internal teams to debug issues.",
    },
    details: {
      type: "object",
      description: "Additional arguments that caused the error",
    },
    type: {
      minLength: 1,
      type: "string",
      enum: ["BadRequestError"],
      description: "The type of error",
    },
  },
  type: "object",
  required: ["name", "status", "message", "requestId", "details", "type"],
} as const;

export const $ToolsExecuteReqDto = {
  properties: {
    actionName: {
      type: "string",
    },
    runInSandbox: {
      type: "boolean",
    },
    input: {
      type: "object",
    },
    nlaInput: {
      type: "string",
    },
    authorizationData: {
      type: "object",
    },
    appSchema: {
      type: "object",
    },
    customDescription: {
      type: "string",
    },
    systemPrompt: {
      type: "string",
    },
    version: {
      type: "string",
    },
  },
  type: "object",
  required: ["actionName", "runInSandbox", "input"],
} as const;

export const $DirectExecuteReqDto = {
  properties: {
    endpoint: {
      type: "string",
    },
    base_url: {
      type: "string",
    },
    headers: {
      type: "object",
    },
    queryParams: {
      type: "object",
    },
    body: {
      type: "object",
    },
  },
  type: "object",
  required: ["endpoint", "base_url", "headers", "queryParams"],
} as const;

export const $ActionExecutionResDto = {
  properties: {
    data: {
      type: "object",
      description: "The response data returned by the action execution.",
    },
    error: {
      type: "string",
      description:
        "The error message, if the action failed to execute. If the action is successful, this will be null.",
    },
    successfull: {
      type: "boolean",
      description:
        "Whether the action execution was successfully executed or not. If this is false, error field will be populated with the error message.",
      deprecated: true,
    },
    successful: {
      type: "boolean",
      description:
        "Whether the action execution was successfully executed or not. If this is false, error field will be populated with the error message.",
    },
  },
  type: "object",
  required: ["data", "successfull", "successful"],
} as const;

export const $CustomAuthDTO = {
  properties: {
    base_url: {
      type: "string",
      description:
        "The base URL (root address) what you should use while making http requests to the connected account. For example, for gmail, it would be 'https://gmail.googleapis.com'",
    },
    parameters: {
      items: {
        $ref: "#/components/schemas/Parameter",
      },
      type: "array",
    },
    body: {
      type: "object",
      description:
        "The body to be sent to the endpoint for authentication. This can either be a JSON field or a string. Note: This is very rarely neeed and is only required by very few apps.",
    },
  },
  type: "object",
  required: ["parameters"],
  description:
    "Custom authentication credentials to use while executing an action.",
} as const;

export const $ActionProxyRequestMethodDTO = {
  properties: {
    type: {
      enum: ["formData", "urlEncoded", "raw", "binary", "graphql", "none"],
      type: "string",
      description:
        "The type of request body to use for the action. Defaults to 'none'.",
    },
    data: {
      type: "string",
      description:
        "The data to be sent to the endpoint. This will override the body set in the connected account.",
    },
  },
  type: "object",
} as const;

export const $GetSingleActionReqDTO = {
  properties: {
    actionId: {
      minLength: 1,
      type: "string",
      description:
        "The id of the action to get details for. This can be found in the id field in [/api/v2/actions](/api-reference/actions/list-actions) endpoint.",
    },
  },
  type: "object",
  required: ["actionId"],
} as const;

export const $GetSingleActionQueryDTO = {
  properties: {
    version: {
      type: "string",
      description: "Version for the action",
    },
  },
  type: "object",
} as const;

export const $ActionProxyRequestConfigDTO = {
  properties: {
    connectedAccountId: {
      type: "string",
      description: "The connected account uuid to use for the action.",
    },
    endpoint: {
      type: "string",
      description:
        "The endpoint to call for the action. If the given url is relative, it will be resolved relative to the base_url set in the connected account info.",
    },
    method: {
      enum: ["GET", "POST", "PUT", "PATCH", "DELETE"],
      type: "string",
      description: "The HTTP method to use for the action.",
    },
    parameters: {
      items: {
        $ref: "#/components/schemas/Parameter",
      },
      type: "array",
    },
    body: {
      type: "object",
      description:
        "The body to be sent to the endpoint. This can either be a JSON field or a string.",
    },
  },
  type: "object",
  required: ["connectedAccountId", "endpoint", "method", "parameters"],
} as const;

export const $SessionInfoDTO = {
  properties: {
    sessionId: {
      type: "string",
    },
    metadata: {
      type: "object",
    },
  },
  type: "object",
  description:
    "Used internally by our SDK's to keep track of the source of execution, ignore it.",
} as const;

export const $NLAArgumentsResponseDTO = {
  properties: {
    arguments: {
      type: "object",
      description:
        "The arguments for the action needed to execute the given task.",
    },
    error: {
      type: "string",
      description:
        "The error message if the arguments were not generated successfully.",
    },
  },
  type: "object",
} as const;

export const $ActionExecutionReqDTO = {
  properties: {
    connectedAccountId: {
      format: "uuid",
      type: "string",
      description:
        "Connected account uuid for the account you want to run the action on. You can get this from the id field in [/api/v1/connectedAccounts](/api-reference/connections/list-connections) endpoint.",
    },
    appName: {
      type: "string",
      description:
        "The name/id of the app that the action belongs to. To get the app name, you can use the [/api/v1/apps](/api-reference/apps/list-apps) endpoint.",
    },
    entityId: {
      type: "string",
      description:
        "(Optional) EntityId that represents your users connections - if the required connection is availabe for the user, it'll be auto-picked. If you are passing this, there's no need to pass `connectedAccountId`. To know more about entityId, [click here](https://backend.composio.dev/patterns/Auth/connected_account#entities)",
    },
    input: {
      type: "object",
      description:
        "Action inputs or aguments to execute the action. This is a dict/map with key-value structure, depdning on the action schema you can find in [/api/v2/actions/{actionName}](/api-reference/actions/get-single-action) endpoint.",
    },
    sessionInfo: {
      $ref: "#/components/schemas/SessionInfoDTO",
    },
    authConfig: {
      $ref: "#/components/schemas/CustomAuthDTO",
    },
    text: {
      type: "string",
      description:
        "The use-case description for the action, this will give context to LLM to generate the correct inputs for the action.",
    },
    customDescription: {
      type: "string",
      description:
        "The custom description for the action, use this to provide customised context about the action to the LLM to suit your use-case.",
    },
    systemPrompt: {
      type: "string",
      description:
        "The system prompt to be used by LLM, use this to control and guide the behaviour of the LLM.",
    },
    version: {
      type: "string",
      description: "Version of the action you want to execute.",
    },
  },
  type: "object",
} as const;

export const $ActionGetNLAInputsReqDTO = {
  properties: {
    text: {
      minLength: 1,
      type: "string",
      description:
        "The use-case description for the action, this will give context to LLM to generate the correct inputs for the action.",
    },
    customDescription: {
      type: "string",
      description:
        "The custom description for the action, use this to provide customised context about the action to the LLM to suit your use-case.",
    },
    systemPrompt: {
      type: "string",
      description:
        "The system prompt to be used by LLM, use this to control and guide the behaviour of the LLM.",
    },
  },
  type: "object",
  required: ["text"],
} as const;

export const $ProxyExecutionReqDTO = {
  properties: {
    endpoint: {
      type: "string",
    },
    connectedAccountId: {
      type: "string",
    },
  },
  type: "object",
  required: ["endpoint", "connectedAccountId"],
} as const;

export const $ActionNotFoundError = {
  properties: {
    name: {
      minLength: 1,
      type: "string",
      enum: ["ActionNotFoundError"],
      description: "The error name",
    },
    status: {
      minLength: 1,
      type: "number",
      description: "HTTP status code",
    },
    message: {
      minLength: 1,
      type: "string",
      description: "Error message",
    },
    requestId: {
      type: "string",
      description:
        "Request ID, used for tracing the request. This is very helpful for internal teams to debug issues.",
    },
    type: {
      minLength: 1,
      type: "string",
      enum: ["NotFoundError"],
      description: "The name of the operation that caused the error",
    },
  },
  type: "object",
  required: ["name", "status", "message", "requestId", "type"],
} as const;

export const $ActionDetailsMinimal = {
  properties: {
    description: {
      type: "string",
      description:
        "The description of the action, tailored to improve the LLM accuracy and reasoning. Use this a tool/function description.",
    },
    displayName: {
      type: "string",
      description:
        "The display name of the action, used to identify the action in the UI.",
    },
    logo: {
      type: "string",
      description: "The logo of the app that the action belongs to.",
    },
    name: {
      type: "string",
      description:
        "The name of the action, used to identify the action in the UI.",
    },
    tags: {
      items: {
        type: "string",
      },
      type: "array",
      description:
        "The tags of the action, used to categorize the action in the UI.",
    },
    deprecated: {
      type: "boolean",
      description:
        "Whether the action is deprecated, if true, avoid using this action.",
    },
  },
  type: "object",
  required: ["description", "displayName", "logo", "name", "tags"],
} as const;

export const $ActionsTagQueryReqDTO = {
  properties: {
    apps: {
      type: "string",
      description:
        "Comma separated list of app names to filter the action tags by.",
    },
  },
  type: "object",
} as const;

export const $ActionDetails = {
  properties: {
    parameters: {
      type: "object",
      description:
        "Required parameters for the action to execute. For example, if the action is GMAIL_SEND_EMAIL, the required parameters for actions execution would be the email address, subject, and body.",
    },
    response: {
      type: "object",
      description:
        "Expected response structure after action execution. You can use this to quickly check what happened with the action execution.",
    },
    appKey: {
      type: "string",
      description:
        "The name of the app that the action belongs to. This is same as appId.",
    },
    appName: {
      type: "string",
      description: "The name of the app that the action belongs to, ",
    },
    appId: {
      type: "string",
      description:
        "The id of the app that the action belongs to. This is same as the appKey. Please use appKey instead.",
      deprecated: true,
    },
    version: {
      type: "string",
      description: "Version of the action schema.",
    },
    available_versions: {
      items: {
        type: "object",
      },
      type: "array",
      description: "List of availavle versions of the action.",
    },
    no_auth: {
      type: "boolean",
      description: "Whether or not the action requires auth or not",
    },
    description: {
      type: "string",
      description:
        "The description of the action, tailored to improve the LLM accuracy and reasoning. Use this a tool/function description.",
    },
    displayName: {
      type: "string",
      description:
        "The display name of the action, used to identify the action in the UI.",
    },
    logo: {
      type: "string",
      description: "The logo of the app that the action belongs to.",
    },
    name: {
      type: "string",
      description:
        "The name of the action, used to identify the action in the UI.",
    },
    tags: {
      items: {
        type: "string",
      },
      type: "array",
      description:
        "The tags of the action, used to categorize the action in the UI.",
    },
    deprecated: {
      type: "boolean",
      description:
        "Whether the action is deprecated, if true, avoid using this action.",
    },
  },
  type: "object",
  required: [
    "parameters",
    "response",
    "appKey",
    "appName",
    "appId",
    "version",
    "available_versions",
    "no_auth",
    "description",
    "displayName",
    "logo",
    "name",
    "tags",
  ],
} as const;

export const $ActionsTagsResponseDTO = {
  properties: {
    items: {
      items: {
        type: "string",
      },
      type: "array",
      description: "List of all the action tags available in composio",
    },
  },
  type: "object",
  required: ["items"],
} as const;

export const $ActionsListResponseDTO = {
  properties: {
    items: {
      items: {
        $ref: "#/components/schemas/ActionDetails",
      },
      type: "array",
    },
    page: {
      type: "number",
      description: "Current page number in the paginated response",
      example: 1,
    },
    totalPages: {
      type: "number",
      description: "Total number of pages available",
    },
  },
  type: "object",
  required: ["items", "page", "totalPages"],
} as const;

export const $ActionsMinimalListResponseDTO = {
  properties: {
    items: {
      items: {
        $ref: "#/components/schemas/ActionDetailsMinimal",
      },
      type: "array",
    },
    page: {
      type: "number",
    },
    totalPages: {
      type: "number",
    },
  },
  type: "object",
  required: ["items", "page", "totalPages"],
} as const;

export const $AdvancedUseCaseSearchBodyDTO = {
  properties: {
    useCase: {
      type: "string",
    },
  },
  type: "object",
} as const;

export const $AdvancedUseCaseSearchQueryDTO = {
  properties: {
    useCase: {
      type: "string",
      deprecated: true,
      description:
        "Use case is deprecated. Please provide this in the body instead to avoid max-uri-length error.",
    },
    limit: {
      type: "number",
    },
    maxActionsPerTask: {
      type: "number",
    },
    minActionsPerTask: {
      type: "number",
    },
    apps: {
      type: "string",
    },
    filterByAvailableApps: {
      type: "boolean",
    },
  },
  type: "object",
} as const;

export const $AdvancedUseCaseSearchTask = {
  properties: {
    app: {
      type: "string",
    },
    actions: {
      items: {
        type: "string",
      },
      type: "array",
    },
    description: {
      type: "string",
    },
    order: {
      type: "number",
    },
  },
  type: "object",
  required: ["app", "actions", "description", "order"],
} as const;

export const $AdvancedUseCaseSearchResponse = {
  properties: {
    items: {
      items: {
        $ref: "#/components/schemas/AdvancedUseCaseSearchTask",
      },
      type: "array",
    },
  },
  type: "object",
  required: ["items"],
} as const;

export const $ExecuteActionResDTO = {
  properties: {
    response_data: {
      type: "boolean",
      description: "Indicates if the action was executed successfully",
    },
    execution_details: {
      type: "object",
      description: "Details of the execution status",
    },
  },
  type: "object",
  required: ["response_data", "execution_details"],
} as const;

export const $ActionsQueryDTO = {
  properties: {
    appNames: {
      type: "string",
      description: "Names of the apps",
    },
    useCase: {
      type: "string",
      description: "Use case",
    },
    showEnabledOnly: {
      type: "boolean",
      description: "Show enabled only",
    },
    limit: {
      type: "number",
      description: "Limit",
    },
    apps: {
      type: "string",
    },
    actions: {
      type: "string",
    },
    tags: {
      type: "string",
    },
    usecaseLimit: {
      type: "number",
    },
    filterImportantActions: {
      type: "boolean",
    },
    showAll: {
      type: "boolean",
    },
    page: {
      type: "number",
    },
  },
  type: "object",
} as const;

export const $ActionsControllerV1 = {
  properties: {
    getAction: {
      items: {
        type: "object",
      },
      type: "array",
    },
  },
  type: "object",
  required: ["getAction"],
} as const;

export const $OAuth2CallbackQueryDto = {
  properties: {
    state: {
      type: "string",
    },
  },
  type: "object",
  required: ["state"],
} as const;

export const $RedirectUriDTO = {
  properties: {
    redirectUri: {
      type: "string",
    },
  },
  type: "object",
} as const;

export const $ReadOnlyQueryReqDTO = {
  properties: {
    query: {
      minLength: 1,
      type: "string",
    },
  },
  type: "object",
  required: ["query"],
} as const;

export const $GenerateCLISessionReqDTO = {
  properties: {
    channel_name: {
      type: "string",
      description: "The channel name for the CLI session",
    },
  },
  type: "object",
  required: ["channel_name"],
} as const;

export const $GenerateCLISessionResDTO = {
  properties: {
    key: {
      type: "string",
      description: "The key for the CLI session",
    },
  },
  type: "object",
  required: ["key"],
} as const;

export const $GetCLISessionResDTO = {
  properties: {
    clientId: {
      type: "string",
      description: "The client ID",
    },
    cliCode: {
      type: "string",
      description: "The CLI code",
    },
  },
  type: "object",
  required: ["clientId", "cliCode"],
} as const;

export const $VerifyCLICodeResDTO = {
  properties: {
    clientId: {
      type: "string",
      description: "The client ID",
    },
    cliCode: {
      type: "string",
      description: "The CLI code",
    },
    apiKey: {
      type: "string",
      description: "The API key associated with the client",
    },
  },
  type: "object",
  required: ["clientId", "cliCode", "apiKey"],
} as const;

export const $CLIQueryDTO = {
  properties: {
    key: {
      type: "string",
      description: "Unique key for CLI session",
    },
    code: {
      type: "string",
      description: "Code for CLI verification",
    },
  },
  type: "object",
  required: ["key"],
} as const;

export const $MetadataReqDTO = {
  properties: {
    email: {
      type: "string",
      description: "The email associated with the metadata request",
    },
    metadata: {
      description: "Additional metadata as a key-value pair",
    },
  },
  type: "object",
  required: ["email"],
} as const;

export const $TriggersEnabledToggleReqDTO = {
  properties: {
    enabled: {
      type: "boolean",
      description: "Flag to enable or disable triggers",
    },
  },
  type: "object",
  required: ["enabled"],
} as const;

export const $TriggersEnabledToggleResDTO = {
  properties: {
    message: {
      type: "string",
      description: "Message indicating the result of the toggle operation",
    },
  },
  type: "object",
  required: ["message"],
} as const;

export const $TriggerToggleInfoResponseDTO = {
  properties: {
    triggersEnabled: {
      type: "boolean",
      description: "Indicates if triggers are enabled",
    },
  },
  type: "object",
  required: ["triggersEnabled"],
} as const;

export const $ToggleTriggerStateResponseDTO = {
  properties: {
    message: {
      type: "string",
    },
  },
  type: "object",
  required: ["message"],
} as const;

export const $MetadataQueryDTO = {
  properties: {
    email: {
      type: "string",
      description: "Email of the client",
    },
  },
  type: "object",
  required: ["email"],
} as const;

export const $TriggerMetadata = {
  properties: {
    id: {
      type: "string",
      description: "The unique id of the log",
    },
    type: {
      type: "string",
      description: "The type of the log",
      oneOf: [
        {
          type: "string",
          enum: ["trigger"],
        },
      ],
    },
    createdAt: {
      pattern: "\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d.\\d+Z?",
      type: "string",
      description: "The date and time when the log was created",
      format: "date-time",
    },
    updatedAt: {
      pattern: "\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d.\\d+Z?",
      type: "string",
      description: "The date and time when the log was updated",
      format: "date-time",
    },
    provider: {
      type: "string",
      description: "The provider of the log",
    },
    clientId: {
      type: "string",
      description: "The client uuid of the log",
    },
    connectionId: {
      type: "string",
      description: "The connection id of the log",
    },
    triggerProviderPayload: {
      type: "string",
      description: "The trigger provider payload of the log",
    },
    triggerClientPayload: {
      type: "string",
    },
    triggerClientError: {
      type: "string",
      description: "The trigger client error of the log",
    },
    triggerName: {
      type: "string",
      description: "The trigger name of the log",
    },
    triggerClientResponse: {
      type: "string",
      description: "The trigger client response of the log",
    },
  },
  type: "object",
  required: [
    "id",
    "type",
    "createdAt",
    "updatedAt",
    "provider",
    "clientId",
    "connectionId",
  ],
  description: "Metadata associated with the trigger log",
} as const;

export const $ActionMetadata = {
  properties: {
    id: {
      type: "string",
      description: "The unique id of the log",
    },
    request: {
      type: "string",
      description: "The request sent to the provider",
    },
    response: {
      type: "string",
      description: "The response from the provider",
    },
    errorRequest: {
      type: "string",
      description: "The error request sent to the provider",
    },
    type: {
      type: "string",
      description: "The type of the log",
      oneOf: [
        {
          type: "string",
          enum: ["action"],
        },
      ],
    },
    createdAt: {
      pattern: "\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d.\\d+Z?",
      type: "string",
      description: "The date and time when the log was created",
      format: "date-time",
    },
    updatedAt: {
      pattern: "\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d.\\d+Z?",
      type: "string",
      description: "The date and time when the log was updated",
      format: "date-time",
    },
    provider: {
      type: "string",
      description: "The provider of the log",
    },
    clientId: {
      type: "string",
      description: "The client uuid of the log",
    },
    connectionId: {
      type: "string",
      description: "The connection id of the log",
    },
    actionName: {
      type: "string",
      description: "The action name of the log",
    },
  },
  type: "object",
  required: [
    "id",
    "request",
    "type",
    "createdAt",
    "updatedAt",
    "provider",
    "clientId",
    "connectionId",
    "actionName",
  ],
} as const;

export const $TriggerLogData = {
  properties: {
    id: {
      type: "string",
      description: "The unique identifier of the trigger log",
    },
    connectionId: {
      type: "string",
      description: "The connection identifier associated with the trigger log",
    },
    clientId: {
      type: "string",
      description: "The client identifier associated with the trigger log",
    },
    status: {
      type: "string",
      description: "The status of the trigger log",
    },
    appName: {
      type: "string",
      description:
        "The name of the application associated with the trigger log",
    },
    createdAt: {
      pattern: "\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d.\\d+Z?",
      type: "string",
      description: "The creation date and time of the trigger log",
      format: "date-time",
    },
    type: {
      type: "string",
      description: "The type of the log",
      oneOf: [
        {
          type: "string",
          enum: ["trigger"],
        },
      ],
    },
    meta: {
      $ref: "#/components/schemas/TriggerMetadata",
    },
  },
  type: "object",
  required: [
    "id",
    "connectionId",
    "clientId",
    "status",
    "appName",
    "createdAt",
    "type",
    "meta",
  ],
} as const;

export const $ActionLogData = {
  properties: {
    id: {
      type: "string",
      description: "The unique identifier of the action log",
    },
    connectionId: {
      type: "string",
      description: "The connection identifier associated with the action log",
    },
    clientId: {
      type: "string",
      description: "The client identifier associated with the action log",
    },
    status: {
      type: "string",
      description: "The status of the action log",
    },
    appName: {
      type: "string",
      description: "The name of the application associated with the action log",
    },
    createdAt: {
      pattern: "\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d.\\d+Z?",
      type: "string",
      description: "The creation date and time of the action log",
      format: "date-time",
    },
    type: {
      type: "string",
      description: "The type of the log",
      oneOf: [
        {
          type: "string",
          enum: ["action"],
        },
      ],
    },
    meta: {
      $ref: "#/components/schemas/ActionMetadata",
    },
  },
  type: "object",
  required: [
    "id",
    "connectionId",
    "clientId",
    "status",
    "appName",
    "createdAt",
    "type",
    "meta",
  ],
} as const;

export const $LogsResDTO = {
  properties: {
    nextCursor: {
      type: "string",
      description: "The cursor to get the next page of logs",
    },
    data: {
      items: {
        type: "object",
      },
      type: "array",
      description: "Logs data",
    },
  },
  type: "object",
  required: ["data"],
} as const;

export const $GetLogsDTO = {
  properties: {
    time: {
      enum: ["5m", "30m", "6h", "1d", "1w", "1month", "1y"],
      type: "string",
      description: "Return logs from the last N time units",
    },
    status: {
      enum: ["all", "success", "error"],
      type: "string",
      description: "Filter logs by their status level, defaults to all",
    },
    search: {
      type: "string",
      description: "Search term to filter logs by",
    },
    integrationId: {
      format: "uuid",
      type: "string",
      description:
        "The ID/UUID of the integration to filter connections by. You can get the integration ID from the [/api/v1/integrations](/api-reference/integrations/list-integrations) endpoint.",
    },
    entityId: {
      type: "string",
      description:
        "Filter logs by entity Id, useful for debugging issues for your specific users. Learn more about entityId [here](https://docs.composio.dev/patterns/Auth/connected_account)",
    },
    limit: {
      type: "number",
      description: "Maximum number of logs to return, defaults to 10",
      default: 10,
    },
    cursor: {
      type: "string",
      description:
        "Cursor for pagination, used to fetch next set of logs. You can get the cursor from the previous response of this endpoint.",
    },
    logsType: {
      enum: ["action", "trigger"],
      type: "string",
      description: "Type of the log",
    },
    sessionId: {
      type: "string",
      description:
        "Session ID of the log, used to filter logs by session. Helpful in debugging issues with specific logs.",
    },
  },
  type: "object",
} as const;

export const $IngestDataDTO = {
  properties: {
    connectionId: {
      type: "string",
      description: "Connection ID of the log",
    },
    sessionId: {
      type: "string",
      description: "Session ID of the log",
    },
    logsType: {
      type: "string",
      description: "Type of the log",
    },
    entityId: {
      type: "string",
      description: "Entity ID of the log",
    },
    providerName: {
      type: "string",
      description: "Provider name of the log",
    },
    actionName: {
      type: "string",
      description: "Action name of the log",
    },
    request: {
      type: "object",
    },
    response: {
      type: "object",
    },
    isError: {
      type: "boolean",
    },
  },
  type: "object",
  required: ["providerName", "actionName", "request", "response", "isError"],
} as const;

export const $IngestDataResponseDTO = {
  properties: {
    isIngested: {
      type: "boolean",
    },
  },
  type: "object",
  required: ["isIngested"],
} as const;

export const $ActionsQueryV2DTO = {
  properties: {
    apps: {
      type: "string",
      description:
        "Comma separated list of composio apps to filter by. You can get the list of apps by using [/api/v1/apps](/api-reference/apps/list-apps) endpoint.",
    },
    actions: {
      type: "string",
      description:
        "Comma separated list of composio actions to filter by. You can get the list of actionIds from this API or you can get it by running `composio actions` command in your terminal.",
    },
    tags: {
      type: "string",
      description:
        "Comma separated list of composio action tags to filter by. You can get the list of action tags by using [/api/v2/actions/list/tags](/api-reference/actions/list-action-tags) endpoint.",
    },
    useCase: {
      type: "string",
      description:
        "Smart use-case based search for actions needed to be performed as per the use-case. This uses AI to understand the use-case and then finally returns the list of actions. **Note:** If you are using this field, you can not use actions or tags fields.",
    },
    page: {
      type: "number",
      description: "Page number to be returned, default is 1",
      minimum: 1,
    },
    limit: {
      type: "number",
      description: "Limit the number of actions to be returned, default is 30",
      minimum: 1,
    },
    filterImportantActions: {
      type: "boolean",
      description:
        "Filter and return only important actions. This is equivalent to setting tags='important' in the query params mentioned above.",
    },
    sortBy: {
      enum: ["alphabet", "usage", "no_sort"],
      type: "string",
      description: "Sort the actions by usage or alphabetical",
    },
  },
  type: "object",
} as const;

export const $FileInfoDTO = {
  properties: {
    app: {
      type: "string",
      description: "Name of the app where this file belongs to.",
    },
    action: {
      type: "string",
      description: "Name of the action where this file belongs to.",
    },
    filename: {
      type: "string",
      description: "Name of the original file.",
    },
    mimetype: {
      type: "string",
      description: "Mime type of the original file.",
    },
    md5: {
      type: "string",
      description: "MD5 of a file.",
    },
  },
  type: "object",
  required: ["app", "action", "filename", "mimetype", "md5"],
} as const;

export const $GetFilesResponseDTO = {
  properties: {
    items: {
      $ref: "#/components/schemas/FileInfoDTO",
      items: {
        type: "object",
      },
      type: "array",
    },
  },
  type: "object",
  required: ["items"],
} as const;

export const $CreateUploadURLResponseDTO = {
  properties: {
    id: {
      type: "string",
      description: "ID of the file",
    },
    url: {
      type: "string",
      description: "Onetime upload URL",
    },
    key: {
      type: "string",
      description: "S3 upload location",
    },
  },
  type: "object",
  required: ["id", "url", "key"],
} as const;

export const $TimePeriodReqDTO = {
  properties: {
    lastTimePeriod: {
      enum: ["DAY", "WEEK", "MONTH", "SIX_MONTH", "YEAR", "FIVE_YEAR"],
      type: "string",
      description: "Time period to get the data for",
    },
  },
  type: "object",
} as const;

export const $ActionByAppDTO = {
  properties: {
    appName: {
      type: "string",
      description: "Name of the app",
    },
    totalCount: {
      type: "number",
      description: "Total count of actions for the app",
    },
  },
  type: "object",
  required: ["appName", "totalCount"],
  description: "Action counts by app",
} as const;

export const $ActionByStatusDTO = {
  properties: {
    failed: {
      type: "number",
      description: "Count of failed actions",
    },
    success: {
      type: "number",
      description: "Count of successful actions",
    },
  },
  type: "object",
  required: ["failed", "success"],
  description: "Action counts by status",
} as const;

export const $ActionAnalyticsDTO = {
  properties: {
    date: {
      type: "string",
      description: "Date of the action",
      format: "date",
    },
    byApp: {
      $ref: "#/components/schemas/ActionByAppDTO",
    },
    byStatus: {
      $ref: "#/components/schemas/ActionByStatusDTO",
    },
  },
  type: "object",
  required: ["date", "byApp", "byStatus"],
  description:
    "Comprehensive trigger analytics data, presenting a breakdown by day, status, and provider for all triggers",
} as const;

export const $IntegrationsWithCountsDTO = {
  properties: {
    id: {
      type: "string",
      description: "Unique identifier for the integration",
    },
    appName: {
      type: "string",
      description: "Name of the app",
    },
    integrationName: {
      type: "string",
      description: "Name of the integration",
    },
    connectionCount: {
      type: "number",
      description: "Count of connections for the integration",
    },
    triggerCount: {
      type: "number",
      description: "Count of triggers for the integration",
    },
    requestLogsCount: {
      type: "number",
      description: "Count of request logs for the integration",
    },
  },
  type: "object",
  required: [
    "id",
    "appName",
    "integrationName",
    "connectionCount",
    "triggerCount",
    "requestLogsCount",
  ],
  description:
    "Detailed integration analytics data, including a breakdown of connection count, trigger count, and request logs count for each integration",
} as const;

export const $AppNameCountDTO = {
  properties: {
    appName: {
      type: "string",
      description: "Name of the app",
    },
    connectionCount: {
      type: "number",
      description: "Count of connections for the app",
    },
    triggerCount: {
      type: "number",
      description: "Count of triggers for the app",
    },
    requestLogsCount: {
      type: "number",
      description: "Count of request logs for the app",
    },
  },
  type: "object",
  required: ["appName", "connectionCount", "triggerCount", "requestLogsCount"],
  description:
    "Comprehensive app-level analytics data, providing a breakdown of connection count, trigger count, and request logs count for each app",
} as const;

export const $AnalyticsDataReqDTO = {
  properties: {
    lastTimePeriod: {
      enum: ["DAY", "WEEK", "MONTH", "SIX_MONTH", "YEAR", "FIVE_YEAR"],
      type: "string",
      description: "Time period to get the data for",
    },
  },
  type: "object",
} as const;

export const $ClientUniqueUserIdCountDTO = {
  properties: {
    clientUniqueUserId: {
      type: "string",
      description: "Client unique user id",
    },
    count: {
      type: "number",
      description: "Count of connections for the client unique user id",
    },
  },
  type: "object",
  required: ["clientUniqueUserId", "count"],
  description: "Connection counts by entity",
} as const;

export const $AnalyticsEntityDataDTO = {
  properties: {
    byConnections: {
      items: {
        $ref: "#/components/schemas/ClientUniqueUserIdCountDTO",
      },
      type: "array",
    },
    byActions: {
      items: {
        $ref: "#/components/schemas/ClientUniqueUserIdCountDTO",
      },
      type: "array",
      description: "Action counts by entity",
    },
    byTriggers: {
      items: {
        $ref: "#/components/schemas/ClientUniqueUserIdCountDTO",
      },
      type: "array",
      description: "Trigger counts by entity",
    },
  },
  type: "object",
  required: ["byConnections", "byActions", "byTriggers"],
  description:
    "Entity-related analytics data, providing a breakdown by connections, actions, and triggers for each entity. This is include all entity info.",
} as const;

export const $AnalyticsDataResDTO = {
  properties: {
    entity: {
      $ref: "#/components/schemas/AnalyticsEntityDataDTO",
    },
    actions: {
      items: {
        $ref: "#/components/schemas/ActionAnalyticsDTO",
      },
      type: "array",
    },
    trigger: {
      items: {
        $ref: "#/components/schemas/ActionAnalyticsDTO",
      },
      type: "array",
    },
    integrations: {
      items: {
        $ref: "#/components/schemas/IntegrationsWithCountsDTO",
      },
      type: "array",
    },
    app: {
      $ref: "#/components/schemas/AppNameCountDTO",
    },
  },
  type: "object",
  required: ["entity", "actions", "trigger", "integrations", "app"],
} as const;

export const $TopEntitiesResDTO = {
  properties: {
    entities: {
      items: {
        $ref: "#/components/schemas/TConnectionCountDTO",
      },
      type: "array",
      description: "Top entities by connection count",
    },
  },
  type: "object",
  required: ["entities"],
} as const;

export const $TConnectionCountDTO = {
  properties: {
    clientUniqueUserId: {
      type: "string",
      description: "Name of the entity",
    },
    count: {
      type: "number",
      description: "Count of connections for the entity",
    },
  },
  type: "object",
  required: ["clientUniqueUserId", "count"],
} as const;

export const $EntityQueryReqDTO = {
  properties: {
    query: {
      type: "string",
      description: "Query to get the data for",
    },
  },
  type: "object",
} as const;

export const $WebhookReqDTO = {
  properties: {
    eventWebhookURL: {
      type: "string",
      description: "Event Webhook URL",
    },
  },
  type: "object",
  required: ["eventWebhookURL"],
} as const;

export const $FetchQueryDTO = {
  properties: {
    startTime: {
      pattern: "\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d.\\d+Z?",
      type: "string",
      description: "Start time of the event in ISO 8601 format",
    },
    endTime: {
      pattern: "\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d.\\d+Z?",
      type: "string",
      description: "End time of the event in ISO 8601 format",
    },
  },
  type: "object",
  required: ["startTime", "endTime"],
} as const;

export const $WebhookSecretResDTO = {
  properties: {
    webhookSecret: {
      type: "string",
      description: "Webhook secret",
    },
  },
  type: "object",
  required: ["webhookSecret"],
} as const;

export const $CreateCheckoutSessionReqDto = {
  properties: {
    plan: {
      enum: ["HOBBY", "STARTER", "GROWTH", "ENTERPRISE", "STARTUP"],
      type: "string",
    },
    applyCoupon: {
      type: "boolean",
    },
  },
  type: "object",
  required: ["plan"],
} as const;

export const $SDKErrorResDTO = {
  properties: {
    status: {
      type: "string",
      description: "The status of the SDK error",
    },
  },
  type: "object",
  required: ["status"],
} as const;

export const $OrgProjectListResDTO = {
  properties: {
    projects: {
      items: {
        $ref: "#/components/schemas/ProjectResDTO",
      },
      type: "array",
    },
  },
  type: "object",
  required: ["projects"],
} as const;

export const $UpdateRowAPIDTO = {
  properties: {
    status: {
      enum: ["success", "failed"],
      type: "string",
      description: "Status of the update operation",
    },
    count: {
      type: "number",
      description: "Number of records updated",
    },
  },
  type: "object",
  required: ["status", "count"],
} as const;

export const $AppFilterDTO = {
  properties: {
    uniqueKey: {
      type: "string",
      description: "List of app unique keys to filter by",
    },
    integrationId: {
      type: "string",
      description: "List of app unique keys to filter by",
    },
  },
  type: "object",
} as const;

export const $ComposioSearchConfigDTO = {
  properties: {
    useComposioAuth: {
      type: "boolean",
      description: "Whether to use Composio authentication",
    },
    authScheme: {
      type: "string",
      enum: [
        "OAUTH2",
        "OAUTH1",
        "OAUTH1A",
        "API_KEY",
        "BASIC",
        "BEARER_TOKEN",
        "GOOGLE_SERVICE_ACCOUNT",
        "NO_AUTH",
        "BASIC_WITH_JWT",
        "COMPOSIO_LINK",
        "CALCOM_AUTH",
      ],
      description: "Authentication scheme to use",
    },
  },
  type: "object",
  required: ["authScheme"],
} as const;

export const $ConnectorSearchFilterDTOV2 = {
  properties: {
    app: {
      $ref: "#/components/schemas/AppFilterDTO",
      description: "Filter options for the connector",
    },
    config: {
      $ref: "#/components/schemas/ComposioSearchConfigDTO",
      description: "Filter options for the connector",
    },
  },
  type: "object",
  required: ["app", "config"],
} as const;

export const $ConnectorSearchResDTO = {
  properties: {
    matchedIntegrationIds: {
      items: {
        type: "string",
      },
      type: "array",
      description: "List of matched integration ids",
    },
    appInfo: {
      type: "object",
      description: "App info",
    },
  },
  type: "object",
  required: ["matchedIntegrationIds", "appInfo"],
} as const;

export const $AppInfoPayload = {
  properties: {
    uniqueKey: {
      type: "string",
      description: "List of app unique keys to filter by",
    },
  },
  type: "object",
} as const;

export const $ComposioCreateConfigDTO = {
  properties: {
    name: {
      type: "string",
      description: "Name of the integration",
    },
    useComposioAuth: {
      type: "boolean",
      description:
        "Whether to use Composio authentication, default to true if no auth config is passed. Throws error we're not able to create integration.",
    },
    authScheme: {
      type: "string",
      enum: [
        "OAUTH2",
        "OAUTH1",
        "OAUTH1A",
        "API_KEY",
        "BASIC",
        "BEARER_TOKEN",
        "GOOGLE_SERVICE_ACCOUNT",
        "NO_AUTH",
        "BASIC_WITH_JWT",
        "COMPOSIO_LINK",
        "CALCOM_AUTH",
      ],
      description: "Authentication scheme to use",
    },
    integrationSecrets: {
      type: "object",
      description: "Authentication configuration",
    },
  },
  type: "object",
} as const;

export const $ConnectorCreateReqDTO = {
  properties: {
    app: {
      $ref: "#/components/schemas/AppInfoPayload",
      description: "Filter options for the connector",
    },
    config: {
      $ref: "#/components/schemas/ComposioCreateConfigDTO",
      description: "Filter options for the connector",
    },
  },
  type: "object",
  required: ["app", "config"],
} as const;

export const $CreateConnectorResDTO = {
  properties: {
    integrationId: {
      type: "string",
      description: "List of matched integration IDs",
    },
  },
  type: "object",
  required: ["integrationId"],
} as const;

export const $GetOrCreateConnectorInfo = {
  properties: {
    app: {
      $ref: "#/components/schemas/AppFilterDTO",
      description: "Filter options for the connector",
    },
    config: {
      $ref: "#/components/schemas/ComposioCreateConfigDTO",
      description: "Filter options for the connector",
    },
  },
  type: "object",
  required: ["app", "config"],
} as const;

export const $GetOrCreateConnectorResDTOV2 = {
  properties: {
    integrationId: {
      type: "string",
      description: "Matched integration ID",
    },
    isNewIntegration: {
      type: "boolean",
      description: "Whether a new integration was created",
    },
  },
  type: "object",
  required: ["integrationId"],
} as const;

export const $ConnectionExtraData = {
  properties: {
    redirectURL: {
      type: "string",
      description:
        "The URL to redirect to after the connection is successfully initiated.",
    },
    labels: {
      items: {
        type: "string",
      },
      type: "array",
      description:
        "Array of labels to associate with the connection for organization and filtering.",
    },
  },
  type: "object",
} as const;

export const $ConnectionInitData = {
  properties: {
    initiateData: {
      minLength: 1,
      type: "object",
      description:
        "Data required to initiate the connection. The structure varies based on the integration type.",
    },
    entityId: {
      type: "string",
      description:
        "The entity ID to associate with the connection. Learn more about entities [here](https://docs.composio.dev/patterns/Auth/connected_account#entities).",
    },
    extra: {
      $ref: "#/components/schemas/ConnectionExtraData",
      type: "object",
      description:
        "The URL to redirect to after the connection is successfully initiated.",
    },
  },
  type: "object",
  required: ["initiateData"],
} as const;

export const $InitiateConnectionPayloadDtoV2 = {
  properties: {
    app: {
      $ref: "#/components/schemas/AppFilterDTO",
      description:
        "Filter criteria to identify the app for which to create a connection.",
    },
    config: {
      $ref: "#/components/schemas/ComposioCreateConfigDTO",
      description:
        "Configuration options for the connection, including authentication scheme and settings.",
    },
    connection: {
      $ref: "#/components/schemas/ConnectionInitData",
      description:
        "Additional metadata and configuration options for the connection.",
    },
  },
  type: "object",
  required: ["app", "config", "connection"],
} as const;

export const $IntegrationData = {
  properties: {
    id: {
      minLength: 1,
      type: "string",
      description:
        "Unique identifier of the integration used for this connection.",
    },
    isNewIntegration: {
      minLength: 1,
      type: "boolean",
      description:
        "Indicates whether a new integration was created during this connection process.",
    },
  },
  type: "object",
  required: ["id", "isNewIntegration"],
} as const;

export const $ConnectionResponseV2 = {
  properties: {
    redirectUrl: {
      type: "string",
      description:
        "The URL to redirect to after the connection is successfully initiated.",
    },
    connectionStatus: {
      minLength: 1,
      type: "string",
      enum: ["INITIATED", "ACTIVE", "FAILED", "EXPIRED"],
      description: "The current status of the connection.",
    },
    connectedAccountId: {
      minLength: 1,
      type: "string",
      description: "The unique identifier of the connected account.",
    },
  },
  type: "object",
  required: ["connectionStatus", "connectedAccountId"],
} as const;

export const $InitiateConnectionResponseV2 = {
  properties: {
    integration: {
      $ref: "#/components/schemas/IntegrationData",
      description:
        "Details about the integration associated with this connection.",
    },
    connectionResponse: {
      $ref: "#/components/schemas/ConnectionResponseV2",
      description: "Response data containing connection details and status.",
    },
  },
  type: "object",
  required: ["integration", "connectionResponse"],
} as const;
